**[Ke Bawah](#satu)**

**[Home](../README.md)**

# Kamus Sebagian Istilah Dalam Bahasa Pemrograman

## A. Istilah Umum Pemrograman

1. **Algoritma**: Serangkaian langkah atau instruksi yang dirancang untuk menyelesaikan tugas tertentu.

2. **Bahasa Pemrograman**: Bahasa formal yang digunakan untuk menulis instruksi yang dapat dieksekusi oleh komputer.

3. **Variabel**: Tempat penyimpanan data dalam program yang dapat berubah nilainya.

4. **Fungsi**: Blok kode yang melakukan tugas tertentu dan dapat dipanggil berulang kali.

5. **Loop**: Struktur kontrol yang mengulang serangkaian instruksi.

6. **Kondisional**: Pernyataan yang memungkinkan program mengambil keputusan berdasarkan kondisi tertentu.

7. **Array**: Struktur data yang menyimpan kumpulan elemen dengan tipe data yang sama.

8. **Object**: Instansi dari sebuah class yang memiliki properti dan metode.

9. **Class**: Blueprint atau template untuk membuat objek dalam pemrograman berorientasi objek.

10. **Debugging**: Proses menemukan dan memperbaiki kesalahan (bug) dalam kode.

## B. Peran dan Spesialisasi dalam Pemrograman

1. **Front-end Developer**: Pengembang yang fokus pada bagian aplikasi yang berinteraksi langsung dengan pengguna.

2. **Back-end Developer**: Pengembang yang bekerja pada sisi server dan logika bisnis aplikasi.

3. **Full-stack Developer**: Pengembang yang memiliki kemampuan baik di front-end maupun back-end.

4. **DevOps Engineer**: Spesialis yang menggabungkan pengembangan software dan operasi IT.

5. **Data Scientist**: Ahli yang menganalisis dan menginterpretasikan data kompleks.

6. **Machine Learning Engineer**: Spesialis yang mengembangkan sistem yang dapat belajar dan meningkat dari pengalaman.

7. **UI/UX Designer**: Desainer yang fokus pada pengalaman pengguna dan antarmuka aplikasi.

## C. Teknologi dan Framework

1. **React**: Library JavaScript untuk membangun antarmuka pengguna.

2. **Angular**: Framework untuk membangun aplikasi web dinamis.

3. **Vue.js**: Framework JavaScript progresif untuk membangun UI.

4. **Node.js**: Runtime JavaScript yang memungkinkan eksekusi JavaScript di sisi server.

5. **Django**: Framework web Python tingkat tinggi.

6. **Flask**: Microframework web Python.

7. **Spring**: Framework aplikasi untuk platform Java.

8. **Ruby on Rails**: Framework aplikasi web yang menggunakan bahasa Ruby.

9. **ASP.NET**: Framework untuk membangun aplikasi web dengan C#.

10. **Laravel**: Framework PHP untuk pengembangan web.

## D. Database dan Penyimpanan Data

1. **SQL**: Structured Query Language, bahasa untuk mengelola database relasional.

2. **MySQL**: Sistem manajemen database relasional open-source.

3. **PostgreSQL**: Sistem database relasional open-source yang canggih.

4. **MongoDB**: Database NoSQL yang berorientasi dokumen.

5. **Redis**: Database key-value in-memory yang cepat.

6. **Cassandra**: Database NoSQL terdistribusi yang sangat skalabel.

7. **Elasticsearch**: Mesin pencari dan analisis terdistribusi.

## E. Pengembangan Mobile

1. **Android Studio**: Lingkungan pengembangan terintegrasi (IDE) resmi untuk pengembangan aplikasi Android.

2. **Kotlin**: Bahasa pemrograman modern yang digunakan untuk pengembangan Android.

3. **Swift**: Bahasa pemrograman untuk pengembangan aplikasi iOS.

4. **React Native**: Framework untuk membangun aplikasi mobile lintas platform menggunakan React.

5. **Flutter**: SDK dari Google untuk membangun aplikasi mobile, web, dan desktop dari satu basis kode.

6. **Xamarin**: Platform pengembangan aplikasi mobile lintas platform menggunakan C#.

## F. Cloud Computing dan Infrastruktur

1. **AWS (Amazon Web Services)**: Platform cloud computing yang menyediakan berbagai layanan.

2. **Google Cloud Platform**: Suite layanan cloud computing dari Google.

3. **Microsoft Azure**: Platform cloud computing dari Microsoft.

4. **Docker**: Platform untuk mengemas, mendistribusikan, dan menjalankan aplikasi dalam container.

5. **Kubernetes**: Sistem orkestrasi container open-source.

6. **Serverless Computing**: Model eksekusi komputasi di mana penyedia cloud mengelola alokasi sumber daya secara dinamis.

## G. Version Control dan Kolaborasi

1. **Git**: Sistem kontrol versi terdistribusi.

2. **GitHub**: Platform hosting untuk repositori Git dan kolaborasi.

3. **GitLab**: Platform DevOps berbasis web yang menyediakan kontrol versi dan CI/CD.

4. **Bitbucket**: Layanan hosting repositori Git dan Mercurial.

## H. Keamanan dan Pengujian

1. **Penetration Testing**: Praktik menguji sistem komputer, jaringan, atau aplikasi web untuk menemukan kerentanan keamanan.

2. **Encryption**: Proses mengubah informasi menjadi kode untuk mencegah akses yang tidak sah.

3. **OAuth**: Protokol otorisasi open standard.

4. **Unit Testing**: Metode pengujian perangkat lunak di mana unit individual kode diuji.

5. **Integration Testing**: Fase dalam pengujian perangkat lunak di mana modul perangkat lunak individual digabungkan dan diuji sebagai sebuah grup.

6. **Continuous Integration (CI)**: Praktik mengintegrasikan kode ke dalam repositori bersama secara rutin.

7. **Continuous Deployment (CD)**: Praktik merilis perangkat lunak secara otomatis ke produksi.

## I. Konsep dan Paradigma Pemrograman

1. **Object-Oriented Programming (OOP)**: Paradigma pemrograman berdasarkan konsep "objek".

2. **Functional Programming**: Paradigma pemrograman yang memperlakukan komputasi sebagai evaluasi fungsi matematika.

3. **Reactive Programming**: Paradigma pemrograman dengan aliran data asynchronous dan propagasi perubahan.

4. **Concurrency**: Kemampuan program untuk menjalankan beberapa komputasi secara bersamaan.

5. **Parallelism**: Eksekusi simultan dari perhitungan independen.

6. **Asynchronous Programming**: Model pemrograman yang memungkinkan operasi berjalan secara non-blocking.

## J. Artificial Intelligence dan Machine Learning

1. **Neural Network**: Model komputasi yang terinspirasi oleh sistem saraf biologis.

2. **Deep Learning**: Subset dari machine learning yang menggunakan jaringan neural berlapis banyak.

3. **Natural Language Processing (NLP)**: Cabang AI yang berfokus pada interaksi antara komputer dan bahasa manusia.

4. **Computer Vision**: Bidang AI yang melatih komputer untuk menginterpretasikan dan memahami dunia visual.

5. **Reinforcement Learning**: Area machine learning yang berfokus pada bagaimana agen harus mengambil tindakan dalam suatu lingkungan.

## K. Istilah spesifik yang sering disebutkan

1. **Backend**: Bagian dari aplikasi yang menangani logika bisnis dan interaksi dengan database.

2. **Widget (UI/User Interface)**: Elemen antarmuka pengguna yang dapat digunakan kembali.

3. **XML (UI/User Interface)**: Bahasa markup yang sering digunakan untuk mendefinisikan layout UI dalam pengembangan Android.

4. **Compose (UI/User Interface)**: Toolkit modern untuk membangun native UI di Android.

5. **API (Application Programming Interface)**: Set definisi, protokol, dan alat untuk membangun software aplikasi.

6. **Retrofit**: Library HTTP Client untuk Android dan Java.

7. **Volley**: Library HTTP untuk mentransmisikan data jaringan pada aplikasi Android.

8. **Fast Android Networking**: Library networking untuk Android.

9. **Room**: Library persistence yang menyediakan lapisan abstraksi di atas SQLite.

10. **SQLite**: Database relasional ringan yang populer digunakan dalam aplikasi mobile.

11. **Realm**: Database objek mobile.

# Lanjutan

- **Chunk (kode)**
  Di Lua (dan beberapa bahasa skrip lain), chunk adalah satu unit kode yang dimuat dan dieksekusi sekaligus—bisa berupa file `.lua`, string kode, atau blok `do … end`. Setiap chunk memiliki scope-nya sendiri, jadi variabel lokal di satu chunk nggak bakal bocor ke chunk lain.

- **Chunk (memori)**
  Di level rendah, chunk bisa berarti unit alokasi memori: sepotong blok memori yang di-`malloc`/`free` (C) atau diatur oleh garbage collector (Java, Go).

1. **Variable**
   Wadah untuk menyimpan data (angka, teks, objek).

2. **Function / Method**
   Sekumpulan instruksi yang bisa dipanggil berulang dengan nama tertentu.

3. **Class / Object**

   - _Class_: cetak biru (blueprint) untuk objek.
   - _Object_: instance dari class, membawa state dan behavior sendiri.

4. **Closure**
   Function yang “mengingat” variabel dari scope di sekitarnya meski scope itu sudah berakhir.

5. **Recursion**
   Fungsi memanggil dirinya sendiri untuk menyelesaikan sub-masalah.

6. **Pointer / Reference**

   - _Pointer_ (C/C++): alamat memori langsung.
   - _Reference_ (Java, Python): cara nggak langsung untuk menunjuk objek.

7. **Lambda / Arrow Function**
   Function anonim—biasanya ringkas, sekali pakai.

8. **API (Application Programming Interface)**
   Sekumpulan aturan dan endpoint untuk berkomunikasi antar sistem atau modul.

9. **SDK (Software Development Kit)**
   Paket alat (library, dokumentasi, tools) untuk membangun aplikasi pada platform tertentu.

10. **Framework / Library**

    - _Library_: kode siap pakai yang kamu panggil sesuai kebutuhan.
    - _Framework_: kerangka kerja yang _meng-ontrol_ alur aplikasi (inversion of control).

11. **Compile vs Interpret**

    - _Compile_: terjemahkan seluruh kode ke bahasa mesin sebelum dijalankan.
    - _Interpret_: jalankan kode baris per baris secara langsung.

12. **Bytecode / Intermediate Representation**
    Kode hasil compile yang masih butuh mesin virtual (JVM, CLR) untuk dijalankan.

13. **JIT (Just-In-Time Compiler)**
    Compiler dinamis yang mengubah bytecode jadi native code saat runtime, meningkatkan performa.

14. **VM (Virtual Machine)**
    Lapisan abstraksi yang mengeksekusi bytecode atau instruksi tertentu (mis. Java VM, .NET CLR).

15. **Memory Leak**
    Kebocoran memori—alokasi memori yang tidak dibebaskan sehingga menumpuk dan bikin aplikasi melambat.

16. **Stack vs Heap**

    - _Stack_: untuk penyimpanan variabel lokal dan call stack; ukurannya terbatas.
    - _Heap_: untuk alokasi dinamis (object, struct), ukurannya lebih besar tapi manajemen lebih rumit.

17. **Garbage Collection**
    Mekanisme otomatis untuk membebaskan memori yang sudah tidak terpakai.

18. **Concurrency / Parallelism**

    - _Concurrency_: manajemen banyak tugas secara overlapping (thread, coroutine).
    - _Parallelism_: eksekusi bersamaan pada banyak core CPU/GPU.

19. **Event Loop / Callback / Promise / Async-Await**
    Pola non-blocking untuk menangani I/O dan operasi berat tanpa nge-hang aplikasi.

20. **MVC / MVVM / Clean Architecture**
    Pola desain untuk memisahkan concern (Model-View-Controller, Model-View-ViewModel, dll).

21. **ORM (Object-Relational Mapping)**
    Teknik memetakan object di bahasa pemrograman ke tabel di basis data relasional.

22. **Middleware**
    Lapisan di antara request dan response pada framework web (Express, ASP.NET, dll).

23. **REST / GraphQL**
    Dua gaya API:

    - _REST_: resource-based, endpoint terpisah.
    - _GraphQL_: query flexible lewat satu endpoint.

24. **Dependency Injection**
    Pola untuk menyuntikkan dependensi (object/service) alih-alih membuatnya langsung di dalam class.

25. **SOLID / DRY / KISS / YAGNI**
    Prinsip dan akronim untuk menulis kode yang bersih dan terawat:

    - _SOLID_: lima prinsip OOP.
    - _DRY_: Don’t Repeat Yourself.
    - _KISS_: Keep It Simple, Stupid.
    - _YAGNI_: You Aren’t Gonna Need It.

26. **Algorithm**
    Serangkaian langkah terstruktur untuk menyelesaikan suatu masalah atau melakukan tugas tertentu. Biasanya diekspresikan dalam pseudocode atau bahasa pemrograman.

27. **Data Structure**
    Organisasi dan format penyimpanan data sehingga operasi (penyisipan, penghapusan, pencarian) dapat dijalankan secara efisien. Contoh: Array, Linked List, Stack, Queue, Tree, Graph, Hash Table.

28. **Big O Notation**
    Notasi matematis untuk menggambarkan kompleksitas waktu atau ruang sebuah algoritma dalam skala besar terhadap ukuran input _n_. Contoh: _O(n)_, _O(log n)_, _O(n²)_.

29. **Refactoring**
    Proses menyempurnakan struktur internal kode tanpa mengubah perilaku eksternalnya, bertujuan meningkatkan keterbacaan, pemeliharaan, dan performa.

30. **Version Control**
    Sistem pencatatan perubahan file kode sumber dari waktu ke waktu, sehingga pengembang dapat kembali ke versi sebelumnya jika diperlukan. Contoh: Git, Subversion, Mercurial.

31. **Branching & Merging**

    - _Branching_: membuat garis pengembangan terpisah dalam repositori untuk fitur atau perbaikan baru.
    - _Merging_: menggabungkan perubahan dari satu branch ke branch lain, sering membutuhkan penyelesaian konflik kode.

32. **Continuous Integration / Continuous Deployment (CI/CD)**
    Praktik otomatisasi build, pengujian, dan penerapan (deployment) aplikasi setiap kali kode disubmit ke repositori, guna mendeteksi masalah lebih cepat dan mempercepat rilis.

33. **Containerization**
    Teknologi mengemas aplikasi beserta seluruh dependensinya ke dalam unit portable (container), sehingga dapat dijalankan konsisten di berbagai lingkungan. Contoh: Docker, Podman.

34. **Orchestration (Kubernetes)**
    Sistem otomasi manajemen container pada skala besar, mencakup penjadwalan, penskalaan, self-healing, dan load balancing.

35. **Microservices vs Monolithic**

    - _Monolithic_: aplikasi dibangun sebagai satu kesatuan utuh.
    - _Microservices_: aplikasi dipecah menjadi layanan-layanan kecil yang berdiri sendiri dan saling berkomunikasi melalui API.

36. **SOAP (Simple Object Access Protocol)**
    Protokol komunikasi berbasis XML untuk web service, dengan aturan standar pesan dan header terdefinisi.

37. **WebSocket**
    Protokol komunikasi full-duplex antara client dan server melalui satu koneksi TCP, memungkinkan pertukaran data realtime.

38. **TLS / SSL (Transport Layer Security / Secure Sockets Layer)**
    Protokol enkripsi untuk mengamankan komunikasi di jaringan, terutama pada HTTP (menjadi HTTPS).

39. **Encryption & Decryption**

    - _Encryption_: mengubah data asli menjadi format terenkripsi agar tidak dapat dibaca tanpa kunci.
    - _Decryption_: proses membalikkan enkripsi untuk mendapatkan data asli.

40. **Hashing**
    Transformasi data menjadi nilai tetap (hash) untuk keperluan integritas, penyimpanan password, atau struktur data _hash table_.

41. **Token-Based Authentication (OAuth, JWT)**
    Metode otentikasi di mana server menerbitkan token (JSON Web Token) yang dibawa client untuk membuktikan identitas pada setiap permintaan.

42. **Design Patterns**
    Solusi teruji (best practice) untuk masalah umum dalam desain perangkat lunak. Contoh kategori:

    - _Creational_: Singleton, Factory, Builder.
    - _Structural_: Adapter, Decorator, Facade.
    - _Behavioral_: Observer, Strategy, Iterator.

43. **Unit Test / Integration Test / End-to-End Test**

    - _Unit Test_: pengujian fungsi atau modul terkecil secara terisolasi.
    - _Integration Test_: pengujian interaksi antar modul.
    - _End-to-End Test_: pengujian keseluruhan alur aplikasi seperti dari perspektif pengguna.

44. **Test-Driven Development (TDD)**
    Metode pengembangan di mana penulis kode dimulai dengan menulis _unit test_ yang gagal, kemudian menulis kode minimal agar test lulus, dan melakukan refactoring.

45. **Debugging & Profiling**

    - _Debugging_: proses menemukan dan memperbaiki bug (kesalahan) dalam kode dengan bantuan _debugger_, _breakpoints_, atau _logging_.
    - _Profiling_: analisis performa kode (CPU, memori) untuk mengidentifikasi _bottleneck_ dan optimasi.

46. **Polymorphism**
    Kemampuan objek dari berbagai kelas untuk diakses melalui antarmuka atau tipe yang sama, dengan perilaku spesifik kelasnya masing-masing. Contoh: method `draw()` yang diimplementasikan berbeda oleh kelas `Circle`, `Square`, dan `Triangle`.

47. **Encapsulation**
    Pemisahan detail implementasi internal dari antarmuka publik suatu modul atau objek, biasanya melalui modifier akses (mis. `private`, `protected`, `public`). Tujuannya menjaga konsistensi data dan meminimalkan efek samping.

48. **Inheritance**
    Mekanisme pewarisan sifat dan perilaku (atribut dan method) dari satu kelas (superclass) ke kelas lain (subclass). Memfasilitasi reuse kode dan pembentukan hierarki kelas.

49. **Abstraction**
    Penyederhanaan kompleksitas sistem dengan memodelkan kelas dan objek hanya pada fitur pentingnya, sambil menyembunyikan detail teknis yang tidak relevan.

50. **Duck Typing**
    Pola pada bahasa dinamis di mana kompatibilitas tipe ditentukan oleh keberadaan method atau properti tertentu—“jika terlihat seperti bebek dan bersuara seperti bebek, maka itu bebek”—tanpa memeriksa jenis aslinya.

51. **Static Typing vs. Dynamic Typing**

    - _Static Typing_: tipe variabel ditentukan dan diperiksa saat kompilasi (mis. Java, C#).
    - _Dynamic Typing_: tipe variabel ditentukan saat runtime (mis. Python, Ruby).

52. **Strong Typing vs. Weak Typing**

    - _Strong Typing_: konversi tipe eksplisit diperlukan; operasi antar tipe yang tidak kompatibel dilarang atau memerlukan casting (mis. Python, Java).
    - _Weak Typing_: konversi tipe otomatis diizinkan, kadang menyebabkan perilaku tak terduga (mis. JavaScript, PHP).

53. **Generics / Templates**
    Fitur bahasa yang memungkinkan penulisan kode fungsi atau kelas yang bekerja dengan berbagai tipe data tanpa kehilangan keamanan tipe. Contoh: `List<T>` di Java/C# atau `template<typename T>` di C++.

54. **Type Inference**
    Kemampuan compiler atau interpreter untuk menyimpulkan tipe variabel berdasarkan konteks, tanpa deklarasi eksplisit (mis. `var` di C# 3.0+, `auto` di C++11, `let` di Kotlin).

55. **Memoization**
    Teknik optimasi untuk menyimpan hasil komputasi fungsi pada input tertentu, sehingga pemanggilan berikutnya dengan input yang sama dapat mengembalikan hasil secara instan tanpa penghitungan ulang.

56. **Lazy Evaluation**
    Penundaan evaluasi ekspresi hingga nilai tersebut benar-benar dibutuhkan, membantu peningkatan performa dan penanganan struktur data tak hingga (mis. generator di Python, `Lazy<T>` di .NET).

57. **CORS (Cross-Origin Resource Sharing)**
    Mekanisme keamanan browser yang mengontrol permintaan HTTP dari satu domain ke domain lain, memastikan hanya origin yang diizinkan oleh server yang dapat mengakses sumber daya.

58. **WebAssembly (WASM)**
    Format instruksi biner portabel dan efisien yang dapat dijalankan di browser web maupun lingkungan non-web. Memungkinkan kode ditulis dalam bahasa seperti C/C++/Rust berjalan dengan performa mendekati native.

59. **Content Delivery Network (CDN)**
    Jaringan server terdistribusi yang menyimpan salinan konten statis (gambar, script, stylesheet) di berbagai lokasi geografis untuk mengurangi latensi dan meningkatkan kecepatan pengiriman ke pengguna akhir.

60. **Load Balancer**
    Komponen infrastruktur yang mendistribusikan trafik jaringan atau permintaan aplikasi ke beberapa server backend, guna mencapai ketersediaan, skalabilitas, dan kinerja optimal.

61. **Agile Methodology**
    Pendekatan pengembangan perangkat lunak iteratif dan inkremental yang menekankan kolaborasi tim, umpan balik cepat, dan adaptasi perubahan persyaratan.

62. **Scrum**
    Kerangka kerja Agile yang membagi proyek ke dalam siklus pendek (sprint), dengan peran terdefinisi (Product Owner, Scrum Master, Tim Pengembang) dan artefak (Product Backlog, Sprint Backlog, Increment).

63. **Sprint**
    Periode waktu tetap (biasanya 1–4 minggu) dalam Scrum di mana tim bekerja untuk menyelesaikan sekumpulan user story yang telah diprioritaskan.

64. **Kanban**
    Metode manajemen alur kerja visual yang menggunakan papan Kanban untuk memantau status tugas (To Do, In Progress, Done) dan membatasi pekerjaan yang sedang berjalan (WIP limits).

65. **Waterfall Model**
    Model pengembangan perangkat lunak linier bertahap yang meliputi tahap Analisis, Desain, Implementasi, Pengujian, dan Pemeliharaan, dengan alur maju tanpa iterasi balik.

66. **User Story**
    Deskripsi fungsionalitas dari perspektif pengguna akhir, biasanya dalam format “Sebagai \[aktor], saya ingin \[tujuan], sehingga \[manfaat].”

67. **Use Case**
    Studi kasus terstruktur yang menjelaskan interaksi antara aktor (pengguna atau sistem lain) dan sistem untuk mencapai tujuan fungsional tertentu.

68. **UML (Unified Modeling Language)**
    Bahasa pemodelan standar untuk memvisualisasikan, merancang, dan mendokumentasikan struktur sistem—meliputi diagram kelas, urutan, use case, statechart, dan aktivitas.

69. **ERD (Entity–Relationship Diagram)**
    Diagram yang memodelkan entitas dalam basis data, atributnya, dan hubungan antar entitas untuk tujuan desain basis data relasional.

70. **Normalization**
    Proses strukturisasi tabel basis data menjadi bentuk normal (1NF, 2NF, 3NF, BCNF) untuk menghilangkan duplikasi data dan dependensi anomal.

71. **ACID vs BASE**

    - _ACID_: Sifat Transaksi basis data Relasional—Atomicity, Consistency, Isolation, Durability.
    - _BASE_: Pendekatan NoSQL—Basically Available, Soft state, Eventual consistency.

72. **CAP Theorem**
    Teorema yang menyatakan bahwa sistem terdistribusi tidak dapat menjamin konsistensi (Consistency), ketersediaan (Availability), dan toleransi partisi (Partition tolerance) secara bersamaan—hanya dua dari tiga.

73. **SQL (Structured Query Language)**
    Bahasa deklaratif untuk definisi, manipulasi, dan kontrol data dalam basis data relasional.

74. **NoSQL**
    Kategori sistem penyimpanan data yang tidak menggunakan skema relasional tradisional, meliputi dokumen (MongoDB), kolom (Cassandra), grafik (Neo4j), dan key–value (Redis).

75. **Indexing**
    Struktur data tambahan pada kolom basis data untuk mempercepat operasi pencarian dan penyortiran, dengan trade-off biaya penyimpanan dan overhead penulisan.

76. **Sharding**
    Metode horizontal partitioning pada basis data terdistribusi, di mana kumpulan data besar dipecah ke dalam beberapa server (shard) untuk skala dan kinerja.

77. **Load Testing**
    Proses pengujian aplikasi dengan beban pengguna yang diharapkan untuk mengevaluasi kinerja, kapasitas, dan stabilitas pada kondisi operasi normal.

78. **Stress Testing**
    Pengujian di luar batas beban normal untuk menentukan titik kegagalan sistem dan perilaku saat terjadi kelebihan beban.

79. **OWASP Top 10**
    Daftar sepuluh risiko keamanan umum pada aplikasi web yang dipublikasikan oleh Open Web Application Security Project—contoh: Injection, Broken Authentication, XSS, Insecure Deserialization.

80. **SQL Injection**
    Teknik serangan di mana penyerang menyisipkan perintah SQL berbahaya ke dalam input aplikasi untuk mengakses atau memanipulasi basis data secara tidak sah.

81. **Cross-Site Scripting (XSS)**
    Kerentanan aplikasi web yang memungkinkan eksekusi skrip sisi klien (browser) oleh peretas, biasanya melalui input pengguna yang tidak disanitasi.

82. **Webhook**
    Mekanisme HTTP callback di mana satu aplikasi mengirim notifikasi real-time ke URL yang dispesifikasikan ketika peristiwa tertentu terjadi.

83. **Message Queue**
    Sistem antrian pesan (RabbitMQ, Kafka) yang memungkinkan komunikasi asinkron antar komponen dengan menyimpan dan mengantarkan pesan secara terjamin.

84. **Publish–Subscribe (Pub/Sub)**
    Pola komunikasi di mana penerbit (publisher) mengirim pesan ke topik, dan pelanggan (subscriber) menerima pesan dari topik yang mereka daftarkan tanpa mengetahui identitas penerbit.

85. **Idempotence**
    Karakteristik operasi yang dapat dijalankan berkali-kali dengan efek samping yang sama seperti sekali saja—penting dalam desain API yang tahan kesalahan.

86. **Semantic Versioning**
    Konvensi penomoran versi perangkat lunak dalam format `MAJOR.MINOR.PATCH`, di mana perubahan MAJOR menandakan inkompatibilitas, MINOR penambahan fitur kompatibel, dan PATCH perbaikan bug.

87. **Package Manager**
    Alat untuk mengelola dependensi dan paket perangkat lunak—contoh: npm (JavaScript), pip (Python), NuGet (.NET), Maven (Java).

88. **Dependency Hell**
    Kondisi konflik antar dependensi paket yang mempersulit instalasi atau pembaruan, sering diatasi dengan manajemen versi ketat dan isolasi lingkungan (virtualenv, container).

89. **Reverse Engineering**
    Proses menganalisis perangkat lunak untuk memahami struktur, fungsi, dan kode sumbernya tanpa akses langsung ke kode asli, sering digunakan untuk debugging atau audit keamanan.

90. **Documentation Generator**
    Alat untuk menghasilkan dokumentasi API atau kode secara otomatis dari komentar kode atau metadata—contoh: Javadoc (Java), Doxygen (C/C++), Sphinx (Python).

91. **Static Code Analysis**
    Teknik pemeriksaan kode sumber tanpa menjalankannya, menggunakan alat (linter, analyzer) untuk mendeteksi bug, kerentanan keamanan, dan pelanggaran gaya penulisan.

92. **Code Coverage**
    Metode pengukuran persentase kode yang dieksekusi oleh suite pengujian, membantu menilai efektifitas dan cakupan test.

93. **Linter**
    Alat yang menganalisis kode sumber untuk menemukan kesalahan sintaks, gaya, dan praktik buruk sebelum runtime.

94. **Formatter**
    Alat otomatis yang menyusun ulang tata letak dan gaya kode (indentasi, spasi, baris baru) sesuai pedoman gaya yang ditentukan.

95. **Build Pipeline**
    Rangkaian proses otomatis—termasuk kompilasi, pengujian, dan pembuatan artefak—yang dijalankan setiap kali ada perubahan pada kode sumber.

96. **Continuous Monitoring**
    Pemantauan aplikasi dan infrastruktur secara real-time untuk mendeteksi anomali performa, kegagalan layanan, atau kebutuhan penskalaan.

97. **Canary Deployment**
    Strategi penggelaran di mana versi baru aplikasi diuji pada sebagian kecil pengguna sebelum diluncurkan secara penuh, meminimalkan risiko.

98. **Blue–Green Deployment**
    Teknik rilis yang memelihara dua lingkungan identik (biru dan hijau); satu lingkungan aktif melayani produksi sementara yang lain dipersiapkan untuk rilis baru, memudahkan rollback.

99. **Feature Toggle (Feature Flag)**
    Mekanisme untuk menyalakan atau mematikan fitur di runtime tanpa mengubah kode, memungkinkan eksperimen atau peluncuran bertahap.

100. **Technical Debt**
     Akumulasi kompromi desain atau implementasi (shortcut) yang memudahkan pengembangan cepat namun menambah beban pemeliharaan di masa depan.

101. **Code Smell**
     Gejala atau pola dalam kode yang mengindikasikan kemungkinan masalah desain atau implementasi, seperti duplikasi, metode terlalu panjang, atau struktur berantakan.

102. **Pair Programming**
     Praktik dua pengembang bekerja bersama di satu workstation: “driver” menulis kode sedangkan “navigator” meninjau secara real-time.

103. **Mob Programming**
     Perluasan pair programming dengan tim penuh yang berkolaborasi simultan pada satu workstation untuk meningkatkan kualitas dan pembelajaran bersama.

104. **Changelog**
     Dokumen terstruktur yang mencatat semua perubahan, perbaikan bug, dan fitur baru yang ditambahkan di setiap versi perangkat lunak.

105. **README**
     Berkas teks utama di repositori kode yang menjelaskan tujuan proyek, cara instalasi, penggunaan, dan kontribusi.

106. **Design Document**
     Dokumen formal yang merinci arsitektur, komponen, alur data, dan keputusan teknis sebelum implementasi dimulai.

107. **Domain-Driven Design (DDD)**
     Pendekatan desain perangkat lunak yang memodelkan struktur dan bahasa domain bisnis agar kode mencerminkan konsep nyata dengan jelas.

108. **Event Sourcing**
     Pola penyimpanan keadaan sistem sebagai rangkaian kejadian (events) yang tak dapat diubah, memungkinkan rekonstruksi status pada titik waktu mana pun.

109. **Command Query Responsibility Segregation (CQRS)**
     Pemisahan antara operasi penulisan (command) dan pembacaan (query) data ke dalam model dan antarmuka terpisah untuk optimasi dan skalabilitas.

110. **Serverless Computing**
     Model komputasi di mana penyedia layanan cloud secara otomatis mengalokasikan dan menagih sumber daya berdasarkan eksekusi fungsi, tanpa pengelolaan server oleh pengembang.

111. **Function as a Service (FaaS)**
     Bentuk serverless di mana aplikasi dibangun sebagai kumpulan fungsi kecil yang dipicu oleh peristiwa atau HTTP request.

112. **Edge Computing**
     Pendekatan pemrosesan data di dekat sumber data (edge of network) untuk mengurangi latensi dan beban jaringan.

113. **Service Mesh**
     Lapisan infrastruktur terdistribusi yang mengelola komunikasi layanan-ke-layanan, menyediakan routing, keamanan, dan observability secara transparan.

114. **gRPC**
     Framework RPC open source yang menggunakan Protocol Buffers untuk mendefinisikan dan men-generate kode klien/servis, mendukung komunikasi lintas bahasa dengan performa tinggi.

115. **Remote Procedure Call (RPC)**
     Protokol komunikasi di mana program memanggil fungsi yang dijalankan di proses atau mesin lain seolah-olah lokal.

116. **Reactive Programming**
     Paradigma pemrograman yang fokus pada aliran data (streams) dan propagasi perubahan, memudahkan penanganan operasi asinkron dan event-driven.

117. **Functional Programming**
     Gaya pemrograman yang menekankan fungsi murni (tanpa efek samping), komposisi fungsi, dan struktur data tak dapat diubah (immutable).

118. **Imperative Programming**
     Gaya pemrograman di mana pengembang menuliskan urutan perintah eksplisit untuk memodifikasi keadaan program.

119. **Declarative Programming**
     Gaya pemrograman yang menyatakan apa yang ingin dicapai tanpa menjabarkan langkah-langkah eksekusinya (contoh: SQL, HTML, React JSX).

120. **[Domain-Specific Language (DSL)][dsl]**
     Bahasa pemrograman atau markup khusus untuk domain tertentu, disederhanakan agar lebih ekspresif dalam konteks tersebut (mis. SQL untuk database, HTML untuk markup web).

121. **Module**
     Unit kode yang mengelompokkan fungsi, kelas, dan data terkait dalam satu file atau paket, memudahkan organisasi dan pemisahan tanggung jawab.

122. **Namespace**
     Ruang lingkup penamaan yang menghindari bentrok antar identitas (fungsi, kelas, variabel) dengan memasukkannya ke dalam konteks terpisah.

123. **Package**
     Kumpulan modul yang diatur secara hierarkis, biasanya didistribusikan sebagai satu kesatuan melalui package manager dan memuat metadata (versi, dependensi).

124. **Infrastructure as Code (IaC)**
     Praktik mendefinisikan dan mengelola infrastruktur (server, jaringan, database) menggunakan kode deklaratif atau skrip otomasi, sehingga konfigurasi dapat direview, versioned, dan diulang.

125. **Immutable Infrastructure**
     Arsitektur infrastruktur di mana server atau container tidak diubah setelah dikerahkan; untuk pembaruan, unit baru diproduksi dan unit lama dihentikan.

126. **IaaS / PaaS / SaaS**
     Model layanan cloud:
     \- _Infrastructure as a Service (IaaS)_: penyedia menyediakan infrastruktur virtual (VM, storage).
     \- _Platform as a Service (PaaS)_: tambahan platform runtime (database, web server).
     \- _Software as a Service (SaaS)_: aplikasi lengkap yang disajikan via web.

127. **Configuration Management**
     Alat dan proses untuk menjaga konsistensi pengaturan sistem—contoh: Ansible, Chef, Puppet—termasuk instalasi paket, konfigurasi file, dan manajemen layanan.

128. **Infrastructure Provisioning**
     Proses alokasi sumber daya cloud atau on-premises (VM, network, storage) sebelum penerapan aplikasi, biasanya diotomasi dengan tool seperti Terraform atau CloudFormation.

129. **Service Level Agreement (SLA)**
     Kontrak tertulis antara penyedia layanan dan pelanggan yang menetapkan metrik kualitas layanan (uptime, latency) serta tindakan korektif jika tidak terpenuhi.

130. **Observability**
     Kemampuan sistem untuk dievaluasi pada metrik internalnya melalui _telemetry_: logs, metrics, dan traces, sehingga memudahkan diagnosis dan pemantauan kesehatan.

131. **Telemetry (Logs, Metrics, Traces)**
     \- _Logs_: catatan peristiwa runtime.
     \- _Metrics_: ukuran kuantitatif (CPU, memori, throughput).
     \- _Traces_: rekaman jejak eksekusi permintaan dalam sistem terdistribusi.

132. **Alerting**
     Mekanisme notifikasi otomatis yang menginformasikan tim saat metrik tertentu melewati ambang batas yang telah ditetapkan.

133. **Chaos Engineering**
     Praktik pengujian ketahanan sistem melalui pengenalan gangguan nyata (latency, failover) secara terkendali untuk memvalidasi self-healing dan recovery.

134. **Circuit Breaker Pattern**
     Pola ketahanan untuk mencegah kegagalan berulang dalam sistem terdistribusi dengan memutus (open) atau memulihkan (close) panggilan ke layanan yang bermasalah.

135. **Bulkhead Pattern**
     Pola desain isolasi sumber daya antar komponen sehingga kegagalan di satu area tidak merembet ke area lain, mirip prinsip sekat pada kapal.

136. **Backpressure**
     Mekanisme kontrol aliran di sistem non-blocking (stream, message queue) yang mengatur kecepatan produsen agar tidak membanjiri konsumen.

137. **Idempotent Consumer**
     Desain konsumen pesan atau layanan yang dapat memproses ulang permintaan tanpa menyebabkan efek samping ganda, memudahkan pengiriman ulang.

138. **Blueprint / Template**
     Definisi spesifikasi deployment (infrastruktur, konfigurasi, parameter) yang dapat digunakan ulang untuk menyediakan lingkungan yang konsisten.

139. **Secrets Management**
     Sistem penyimpanan dan distribusi kredensial (API keys, password, sertifikat) secara aman—contoh: HashiCorp Vault, AWS Secrets Manager.

140. **Policy as Code**
     Pendekatan mendefinisikan aturan kebijakan keamanan, kepatuhan, atau biaya dalam format kode terversioning, yang dievaluasi otomatis terhadap infrastruktur atau pipeline.

141. **Reflection**
     Mekanisme runtime untuk memeriksa atau memodifikasi struktur dan metadata program (kelas, metode, properti) secara dinamis.

142. **Decorator**
     Pola desain atau sintaksis (di Python, TypeScript) untuk “membungkus” fungsi atau kelas agar menambahkan perilaku tanpa mengubah definisi aslinya.

143. **Annotation**
     Metadata yang dilampirkan pada kode (kelas, metode, variabel) untuk memberi instruksi pada compiler atau framework (misalnya `@Override` di Java, `@Component` di Spring).

144. **Metaprogramming**
     Teknik di mana kode menulis atau memodifikasi kode lain (atau dirinya sendiri) pada saat compile-time atau runtime.

145. **Aspect-Oriented Programming (AOP)**
     Paradigma yang memisahkan concern transversal (logging, keamanan, transaksi) dari logika bisnis utama melalui “aspek” yang disuntikkan secara otomatis.

146. **Mixin**
     Kelas atau modul yang menyediakan metode atau properti untuk digabungkan ke dalam kelas lain tanpa pewarisan murni, sering digunakan di Python, Ruby, dan JavaScript.

147. **Trait**
     Unit reuse kode yang mirip mixin tetapi dengan konflik resolusi dan komposisi eksplisit, umum di PHP dan Scala.

148. **Hotfix**
     Perbaikan cepat yang diterapkan langsung ke produksi untuk menanggulangi bug kritis tanpa menunggu siklus rilis reguler.

149. **Rollback**
     Proses mengembalikan sistem atau aplikasi ke versi sebelumnya jika versi baru menimbulkan masalah.

150. **Release Candidate (RC)**
     Versi prarilis yang dianggap stabil dan siap diuji luas; jika tidak ditemukan bug kritis, RC akan dijadikan versi produksi.

151. **Beta Testing**
     Fase pengujian yang melibatkan pengguna eksternal untuk mengevaluasi fitur baru sebelum rilis final.

152. **Alpha Testing**
     Pengujian awal di lingkungan terkendali (tim pengembang atau QA) untuk memastikan fungsi dasar berjalan.

153. **Feature Branch**
     Branch terpisah di sistem version control yang dibuat khusus untuk pengembangan fitur baru hingga siap digabung.

154. **Fork**
     Salinan independen dari repositori yang memungkinkan pengembang bereksperimen tanpa memengaruhi proyek asli.

155. **Pull Request**
     Permintaan integrasi perubahan dari satu branch atau fork ke branch target, memfasilitasi diskusi dan review sebelum merge.

156. **Code Review**
     Proses pemeriksaan kode oleh rekan tim untuk memastikan kualitas, konsistensi, dan kepatuhan pada standar sebelum penggabungan.

157. **Merge Request**
     Sinonim atau istilah alternatif untuk pull request pada beberapa platform (GitLab, Bitbucket).

158. **Benchmarking**
     Pengukuran kinerja komponen atau sistem dengan serangkaian uji terstandar untuk membandingkan performa.

159. **Hot Reload**
     Mekanisme di mana perubahan kode diterapkan langsung ke aplikasi yang sedang berjalan tanpa memulai ulang proses, mempercepat siklus pengembangan (mis. Flutter, React).

160. **Infrastructure Drift**
     Kondisi di mana konfigurasi lingkungan aktual menyimpang dari definisi kode (IaC), menuntut rekonsiliasi untuk menjaga konsistensi.

161. **Code Signing**
     Proses menghasilkan tanda tangan digital pada artefak perangkat lunak (biner, paket) untuk memverifikasi integritas dan sumber kode sebelum dijalankan.

162. **Sandboxing**
     Teknik isolasi eksekusi kode dalam lingkungan terbatas (sandbox) untuk membatasi akses ke sistem host dan mencegah potensi kerusakan atau eksploitasi.

163. **Polyfill**
     Potongan kode (biasanya JavaScript) yang menambahkan dukungan untuk fitur bahasa atau API modern di lingkungan yang belum mendukungnya.

164. **Transpiler**
     Alat yang menerjemahkan kode sumber dari satu bahasa ke bahasa lain pada level yang sama (mis. TypeScript → JavaScript, ES6 → ES5).

165. **Bundler**
     Alat yang mengumpulkan modul dan dependensi menjadi satu atau beberapa berkas output teroptimasi untuk dikonsumsi browser atau runtime (mis. Webpack, Rollup).

166. **Minification**
     Proses menghapus karakter tak diperlukan (spasi, komentar, baris baru) dan mengganti nama variabel untuk memperkecil ukuran berkas sumber sebelum produksi.

167. **Tree Shaking**
     Teknik optimasi bundler yang menghilangkan kode yang tidak pernah digunakan (dead exports) dari bundel akhir, mengurangi ukuran paket.

168. **Dead Code Elimination**
     Tahap optimasi compiler yang menghapus instruksi atau fungsi yang dipastikan tidak pernah dieksekusi dalam program.

169. **Ahead-of-Time (AOT) Compilation**
     Proses menerjemahkan bytecode atau bahasa tingkat tinggi menjadi kode mesin native sebelum runtime, mengurangi overhead JIT saat eksekusi.

170. **Source Map**
     Berkas metadata yang memetakan baris dan kolom kode hasil minifikasi atau transpiling kembali ke baris asli, memudahkan debugging.

171. **Proxy Pattern**
     Pola desain struktural di mana objek perantara (proxy) mengontrol akses ke objek sebenarnya, menambah lapisan keamanan atau caching.

172. **Memory Pooling**
     Teknik manajemen memori di mana blok memori dialokasikan sekaligus dalam jumlah besar (pool) dan digunakan kembali untuk objek baru, mengurangi overhead alokasi dinamis.

173. **SIMD (Single Instruction, Multiple Data)**
     Paradigma paralel di level instruksi CPU yang mengeksekusi operasi yang sama pada beberapa data sekaligus, mempercepat komputasi vektor.

174. **Thread Pool**
     Kumpulan thread yang siap digunakan untuk mengeksekusi tugas secara asinkron, menghindari overhead pembuatan dan penghancuran thread berulang kali.

175. **Coroutine**
     Unit eksekusi ringan yang dapat di-_pause_ dan di-_resume_, mempermudah penulisan kode asinkron bergaya sinkron tanpa pembuatan thread baru.

176. **Fiber**
     Bentuk mikro-thread yang menjalankan eksekusi secara bergiliran dalam satu thread OS, memungkinkan manajemen kontekstual yang lebih ringan.

177. **Actor Model**
     Paradigma komputasi terdistribusi di mana “aktor” adalah unit independen yang berkomunikasi melalui pengiriman pesan asinkron tanpa berbagi memori.

178. **Reactor Pattern**
     Pola arsitektur untuk menangani I/O berjumlah besar dengan satu atau beberapa thread melalui pendaftaran event dan callback, efisien pada server high-concurrency.

179. **Logging Levels**
     Pengaturan prioritas pesan log (mis. TRACE, DEBUG, INFO, WARN, ERROR, FATAL) untuk membantu pengembang memilih detail log yang ingin dicatat.

180. **Connection Pooling**
     Teknik manajemen koneksi database di mana koneksi yang sudah ada disimpan dan digunakan kembali untuk permintaan berikutnya, mengurangi latency pembuatan koneksi baru.

181. **Serialization**
     Proses mengubah objek atau struktur data menjadi format byte-sekuens (JSON, XML, Protobuf) untuk penyimpanan atau transmisi.

182. **Deserialization**
     Kebalikan serialisasi: mengonversi kembali byte-sekuens menjadi objek atau struktur data dalam aplikasi.

183. **Marshalling / Unmarshalling**
     Istilah untuk serialisasi/deserialisasi dalam konteks panggilan prosedur jauh (RPC):
     \- _Marshalling_: menyiapkan data untuk dikirim lewat jaringan.
     \- _Unmarshalling_: merekonstruksi data pada sisi penerima.

184. **Shallow Copy vs Deep Copy**
     \- _Shallow Copy_: menyalin struktur terluar objek; referensi ke sub-objek tetap sama.
     \- _Deep Copy_: menyalin seluruh objek dan sub-objek secara rekursif, menghasilkan instance terpisah.

185. **Endianness**
     Urutan byte dalam representasi data multibyte:
     \- _Big-endian_: byte paling signifikan disimpan di alamat terendah.
     \- _Little-endian_: byte paling signifikan disimpan di alamat tertinggi.

186. **Concurrency Model (CSP, Actors, Threads)**
     Pendekatan untuk menulis program paralel/asinkron:
     \- _CSP (Communicating Sequential Processes)_: goroutine + channel (Go).
     \- _Actor Model_: aktor berkomunikasi lewat pesan (Erlang, Akka).
     \- _Threads_: thread OS dengan shared memory dan sinkronisasi.

187. **Mutex / Semaphore**
     Mekanisme sinkronisasi untuk menghindari kondisi balapan:
     \- _Mutex_: kunci eksklusif; hanya satu thread/korutin yang mendapat akses.
     \- _Semaphore_: penghitung akses terbatas ke sumber daya.

188. **Deadlock / Livelock / Starvation**
     \- _Deadlock_: dua atau lebih thread saling menunggu kunci sehingga jalan di tempat.
     \- _Livelock_: thread terus berubah status tanpa kemajuan karena deteksi konflik.
     \- _Starvation_: thread tidak pernah mendapat akses karena prioritas rendah.

189. **Atomic Operation**
     Operasi indivisibel yang dijamin tuntas sepenuhnya atau tidak sama sekali, tanpa interupsi oleh thread lain.

190. **Memory Barrier (Fence)**
     Instruksi CPU yang memerintahkan urutan akses memori agar operasi load/store tidak direorder, krusial untuk konsistensi di multiprosesor.

191. **Lock-Free / Wait-Free Programming**
     Teknik algoritmik untuk menjamin kemajuan thread tanpa penggunaan kunci:
     \- _Lock-Free_: setidaknya satu thread akan menyelesaikan operasi.
     \- _Wait-Free_: setiap thread akan menyelesaikan operasi dalam batas langkah terbatas.

192. **Cache Coherence**
     Protokol hardware (MESI, MOESI) untuk memastikan cache CPU multiprosesor tetap sinkron terhadap memori utama.

193. **False Sharing**
     Kondisi perfoma di mana dua thread mengakses variabel yang berbeda tetapi berada di cache line yang sama, menyebabkan invalidasi cache berlebih.

194. **Virtual Memory / Paging**
     Abstraksi memori di mana alamat virtual dipetakan ke alamat fisik melalui page table; memori di luar RAM dapat disimpan sementara di disk (swap).

195. **Segmentation Fault**
     Kesalahan runtime akibat akses memori di luar batas yang diizinkan (mis. dereferensi pointer NULL atau pointer asing).

196. **Buffer Overflow**
     Kondisi di mana data yang ditulis melebihi alokasi buffer, dapat menyebabkan korupsi memori atau dieksploitasi untuk eksekusi kode jahat.

197. **Stack Smashing Protector (SSP)**
     Mekanisme kompiler (canary value) untuk mendeteksi dan mencegah overwrite return address pada stack.

198. **Symbol Resolution / Linking**
     Proses di mana linker menyelesaikan referensi fungsi dan variabel eksternal ke alamat memori di berkas objektif atau pustaka.

199. **Static Linking vs Dynamic Linking**
     \- _Static Linking_: pustaka dilampirkan ke biner saat build, menghasilkan eksekutabel besar tetapi independen.
     \- _Dynamic Linking_: pustaka dipanggil saat runtime, memungkinkan pembaruan pustaka tanpa rebuild aplikasi.

200. **Loader**
     Komponen OS yang memuat biner ke memori, memetakan segmen, dan mempersiapkan proses sebelum eksekusi.

201. **Breadth-First Search (BFS)**
     Algoritma pencarian graf/traversal yang menjelajahi semua simpul berjarak _k_ sebelum pindah ke simpul berjarak _k+1_, menggunakan antrian (queue) untuk memproses simpul.

202. **Depth-First Search (DFS)**
     Algoritma pencarian graf/traversal yang mengikuti satu cabang sampai habis sebelum _backtrack_, biasanya diimplementasikan secara rekursif atau dengan stack.

203. **Dijkstra’s Algorithm**
     Algoritma untuk menemukan jalur terpendek dari satu simpul ke semua simpul lain pada graf berbobot non-negatif, memanfaatkan struktur data heap/priority queue.

204. \*_A_ Search Algorithm*\*
     Algoritma jalur terpendek yang menggunakan fungsi heuristik *h(n)\* untuk memperkirakan biaya tersisa, menggabungkan keunggulan BFS dan fungsi penilaian (g+h).

205. **Binary Search Tree (BST)**
     Struktur data pohon biner di mana tiap simpul memiliki nilai, anak kiri lebih kecil dan anak kanan lebih besar, memungkinkan operasi pencarian, penyisipan, dan penghapusan dalam _O(log n)_ rata-rata.

206. **Heap (Priority Queue)**
     Struktur data binary heap—minimum-heap atau maksimum-heap—di mana operasi _insert_ dan _extract-min/extract-max_ berjalan dalam _O(log n)_.

207. **Skip List**
     Struktur data probabilistik yang menyediakan operasi pencarian, penyisipan, dan penghapusan dalam _O(log n)_ dengan memanfaatkan beberapa lapisan tautan antar node.

208. **Bloom Filter**
     Struktur data probabilistik untuk pengujian keanggotaan set dengan memori rendah—mungkin menghasilkan _false positive_ tetapi tidak pernah _false negative_.

209. **Log-Structured Merge-Tree (LSM Tree)**
     Struktur data basis data berorientasi tulis yang menunda dan menyusun ulang batch penulisan ke disk, sering digunakan di sistem NoSQL untuk melalui _write amplification_ rendah.

210. **Merkle Tree**
     Pohon hash terstruktur di mana setiap daun di-hash, dan setiap simpul internal adalah hash gabungan dari anaknya, umum di blockchain dan sistem penyimpanan terdistribusi untuk verifikasi data.

211. **Pipelining (CPU)**
     Teknik eksekusi instruksi di mana beberapa tahap (fetch, decode, execute, write-back) diproses secara bersamaan pada instruksi berbeda untuk meningkatkan _throughput_.

212. **Out-of-Order Execution**
     Mekanisme eksekusi instruksi di CPU modern yang tidak mengikuti urutan program literal, melainkan mengeksekusi instruksi yang operannya siap, meningkatkan pemanfaatan unit eksekusi.

213. **Branch Prediction**
     Teknik CPU untuk memperkirakan hasil pengambilan cabang (if/else) sebelum dievaluasi, mengurangi _pipeline stalls_ bila tebakan benar.

214. **Speculative Execution**
     Eksekusi instruksi di luar urutan yang sebenarnya diprogram untuk meningkatkan performa, dengan hasil dibatalkan jika prediksi cabang ternyata salah.

215. **Just-In-Time (JIT) Warmup**
     Fase awal eksekusi aplikasi JIT-compiled di mana metode/metrik profilling dikumpulkan sebelum compiler JIT menghasilkan kode native optimal.

216. **MapReduce**
     Model pemrograman terdistribusi untuk pemrosesan dataset besar:
     \- _Map_: memetakan input ke sepasang (kunci, nilai).
     \- _Reduce_: mengagregasi nilai berdasarkan kunci.

217. **ETL (Extract, Transform, Load)**
     Proses aliran data di mana data di-_extract_ dari sumber, di-_transform_ sesuai skema atau logika, lalu di-_load_ ke gudang data (data warehouse).

218. **Columnar Storage**
     Teknik penyimpanan basis data di mana data disimpan per kolom, bukan per baris, optimal untuk _analytics_ dan _OLAP_ karena kompresi tinggi dan akses kolom tunggal cepat.

219. **Data Lake**
     Repositori terpusat yang menyimpan data mentah (terstruktur maupun tidak) dalam skala besar, memungkinkan fleksibilitas _schema-on-read_ untuk kebutuhan analisis beragam.

220. **Workflow Orchestration (DAG)**
     Definisi dan penjadwalan _Directed Acyclic Graph_ tugas—seperti Apache Airflow—di mana setiap node merepresentasikan langkah pemrosesan data atau pekerjaan, dengan dependensi yang ditentukan arah.

221. **Command-Line Interface (CLI)**
     Antarmuka pengguna berbasis teks di mana perintah diketikkan ke prompt untuk berinteraksi langsung dengan sistem atau aplikasi, sering digunakan untuk otomatisasi dan skrip.

222. **Graphical User Interface (GUI)**
     Antarmuka pengguna yang menampilkan elemen visual (jendela, tombol, menu) untuk interaksi melalui perangkat penunjuk—mempermudah penggunaan bagi non-teknis.

223. **Read–Eval–Print Loop (REPL)**
     Lingkungan interaktif di mana input kode dibaca (read), dievaluasi (eval), hasilnya dicetak (print), lalu siklus diulang; mendukung prototyping cepat dan debugging (mis. Python, Node.js).

224. **Monkey Patching**
     Teknik runtime untuk memodifikasi atau menambah perilaku fungsi atau kelas yang sudah ada tanpa mengubah definisi sumbernya, umum di bahasa dinamis seperti Python dan Ruby.

225. **Continuous Delivery**
     Praktek otomatisasi build dan pengujian sehingga perangkat lunak selalu dalam keadaan siap untuk dirilis ke produksi kapan saja, namun langkah penerapan masih diaktifkan secara manual.

226. **Priority Inversion**
     Kondisi di sistem sekuensial di mana tugas prioritas rendah memegang sumber daya yang dibutuhkan tugas prioritas tinggi, menyebabkan penurunan performa atau deadlock.

227. **Black-Box Testing**
     Metode pengujian perangkat lunak yang berfokus pada fungsionalitas eksternal tanpa melihat struktur internal kode; input diuji berdasarkan spesifikasi dan output diverifikasi.

228. **White-Box Testing**
     Teknik pengujian yang mengeksplorasi struktur internal dan logika program—meliputi pengujian cabang, jalur, dan kondisi—untuk memastikan cakupan kode yang tinggi.

229. **Smoke Testing**
     Pengujian awal pada build baru untuk memverifikasi fungsi dasar bekerja dan tidak ada kegagalan kritis sebelum pengujian lebih mendetail dilakukan.

230. **Sanity Testing**
     Pengujian selektif terhadap bagian tertentu dari aplikasi setelah perubahan kecil untuk memastikan perbaikan telah efektif dan tidak memecah fitur penting lain.

231. **Code Obfuscation**
     Proses mengubah kode sumber atau bytecode menjadi bentuk yang sulit dibaca oleh manusia (minifikasi, renaming simbol) untuk melindungi kekayaan intelektual dan mencegah reverse engineering.

232. **Software License**
     Ketentuan hukum yang mengatur penggunaan, distribusi, dan modifikasi perangkat lunak; contoh populer meliputi MIT, Apache 2.0, GPL, dan BSD.

233. **Cross-Compilation**
     Proses kompilasi kode pada satu platform (host) untuk dijalankan pada platform lain (target) dengan arsitektur atau sistem operasi berbeda.

234. **Polyglot Programming**
     Pendekatan pemilihan berbagai bahasa pemrograman dalam satu sistem sesuai kekuatan masing-masing—misalnya menggunakan Python untuk prototyping dan C++ untuk modul performa kritis.

235. **Asymmetric Encryption**
     Metode kriptografi yang menggunakan sepasang kunci publik dan privat; data dienkripsi dengan kunci publik dan hanya dapat didekripsi dengan kunci privat yang bersesuaian.

236. **Symmetric Encryption**
     Teknik kriptografi di mana pengirim dan penerima menggunakan satu kunci rahasia yang sama untuk proses enkripsi dan dekripsi data, cepat namun memerlukan saluran aman untuk pertukaran kunci.

237. **Zero Trust Architecture**
     Model keamanan yang mengasumsikan tidak ada entitas (user, aplikasi, jaringan) dapat dipercaya secara otomatis, memerlukan otentikasi dan otorisasi berkelanjutan untuk setiap permintaan akses.

238. **Multi-Factor Authentication (MFA)**
     Mekanisme otentikasi yang menggabungkan dua atau lebih faktor (sesuatu yang diketahui, dimiliki, atau biometrik) untuk meningkatkan keamanan akses.

239. **Single Sign-On (SSO)**
     Sistem otentikasi terpusat yang memungkinkan pengguna mengakses berbagai aplikasi dengan satu kali login, menyederhanakan pengalaman pengguna dan manajemen kredensial.

240. **Rate Limiting**
     Teknik kontrol lalu lintas jaringan atau API untuk membatasi jumlah permintaan dalam periode waktu tertentu, mencegah penyalahgunaan dan melindungi sumber daya backend.

241. **OLTP (Online Transaction Processing)**
     Sistem basis data yang dioptimalkan untuk transaksi harian tingkat tinggi dengan operasi baca-tulis singkat, mendukung banyak pengguna secara simultan.

242. **OLAP (Online Analytical Processing)**
     Sistem basis data yang dioptimalkan untuk kueri analitis kompleks dan agregasi data berskala besar, biasanya digunakan untuk intelijen bisnis.

243. **Data Warehouse**
     Repositori terpusat untuk menyimpan data historis terstruktur dari berbagai sumber operasional, dioptimalkan untuk OLAP dan pelaporan.

244. **API Gateway**
     Lapisan perantara yang meneruskan permintaan API ke layanan mikro terkait, menyediakan fungsi lintas-layanan seperti otentikasi, rate limiting, dan routing.

245. **Backend-for-Frontend (BFF)**
     Pola arsitektur di mana satu lapisan backend khusus dibuat untuk setiap antarmuka klien (web, mobile), menyederhanakan logika agregasi data dan adaptasi kebutuhan klien.

246. **WebRTC (Web Real-Time Communication)**
     API browser untuk komunikasi audio, video, dan data peer-to-peer langsung tanpa plugin eksternal, mendukung aplikasi konferensi dan streaming real-time.

247. **HTTP/2 vs HTTP/3**
     \- **HTTP/2**: mendukung multiplexing, header compression (HPACK), dan server push untuk meningkatkan performa web.
     \- **HTTP/3**: berjalan di atas QUIC (UDP), menghilangkan head-of-line blocking dan mempercepat handshake TLS.

248. **QUIC (Quick UDP Internet Connections)**
     Protokol transport berbasis UDP yang mengintegrasikan TLS 1.3, dirancang untuk latensi rendah, multipath, dan koneksi yang lebih cepat dibanding TCP.

249. **Cache-Control Header**
     Direktif HTTP yang mengatur caching browser dan CDN, seperti `max-age`, `no-cache`, atau `public`, untuk mengontrol validitas dan kebijakan penyimpanan.

250. **Service Worker**
     Skrip browser yang berjalan terpisah dari halaman web, memungkinkan intercept dan caching permintaan jaringan, dasar dari aplikasi web progresif (PWA).

251. **PWA (Progressive Web App)**
     Aplikasi web yang memanfaatkan teknologi modern (Service Worker, Web App Manifest) untuk pengalaman mendekati aplikasi native, termasuk kemampuan offline dan instalasi.

252. **SPA (Single Page Application)**
     Aplikasi web di mana navigasi halaman dimanipulasi di klien (JavaScript) tanpa memuat ulang keseluruhan halaman, memberikan pengalaman pengguna lebih cepat.

253. **MPA (Multi-Page Application)**
     Aplikasi web klasik yang memuat ulang seluruh halaman dari server untuk setiap navigasi, cocok untuk situs dengan banyak konten terpisah.

254. **SSG (Static Site Generation)**
     Pra-rendering halaman web menjadi HTML statis saat build time, menghasilkan situs yang cepat dan lebih aman karena tidak ada kode server dinamis saat runtime.

255. **SSR (Server-Side Rendering)**
     Rendermenghasilkan HTML di server untuk setiap permintaan, meningkatkan SEO dan kinerja waktu-muat pertama, tetapi menambah beban server.

256. **ISR (Incremental Static Regeneration)**
     Hibrida SSG dan SSR di mana halaman statis dapat diregenerasi di background sesuai jadwal atau permintaan, menjaga konten tetap up-to-date tanpa rebuild penuh.

257. **Edge Function**
     Fungsi komputasi ringan yang dijalankan di edge network (CDN) dekat pengguna untuk logika kustom, otentikasi, atau manipulasi respons sebelum mencapai origin server.

258. **Compression (gzip, Brotli)**
     Teknik kompresi konten HTTP untuk memperkecil ukuran payload:
     \- _gzip_: algoritma lama, didukung luas.
     \- _Brotli_: algoritma lebih modern dengan rasio kompresi lebih tinggi.

259. **Rate Throttling**
     Penanganan permintaan API saat beban tinggi dengan menunda atau menolak permintaan setelah melewati ambang batas tertentu, menjaga stabilitas sistem.

260. **JAMstack**
     Arsitektur modern untuk membangun situs dan aplikasi web—menggunakan JavaScript di klien, API terpisah, dan markup pra-render (Static Generated Markup)—meningkatkan keamanan dan skalabilitas.

261. **HTTP Status Codes**
     Kode tiga digit yang dikembalikan server dalam respons HTTP untuk menunjukkan hasil permintaan. Contoh: `200 OK`, `404 Not Found`, `500 Internal Server Error`.

262. **Cookie vs. Session**
     \- _Cookie_: data kecil yang disimpan di browser klien, dikirim ke server pada setiap permintaan sesuai domain/path.
     \- _Session_: data yang disimpan di server, diidentifikasi oleh session ID (biasanya disimpan dalam cookie) untuk mempertahankan state pengguna.

263. **Cross-Site Request Forgery (CSRF)**
     Serangan di mana peretas memanfaatkan kredensial autentikasi korban untuk mengirim permintaan tidak sah ke aplikasi web. Biasanya dicegah dengan token CSRF unik.

264. **Security Assertion Markup Language (SAML)**
     Protokol berbasis XML untuk pertukaran data autentikasi dan otorisasi antar domain, umum digunakan dalam Single Sign-On (SSO) di lingkungan enterprise.

265. **Public Key Infrastructure (PKI)**
     Rangkaian kebijakan, prosedur, dan komponen teknis (Certificate Authority, Registration Authority) yang mengelola pembuatan, distribusi, dan pencabutan sertifikat digital.

266. **Certificate Signing Request (CSR)**
     Permintaan yang dihasilkan oleh server atau klien untuk memperoleh sertifikat digital dari Certificate Authority, berisi public key dan informasi identitas.

267. **X.509 Certificate**
     Standar sertifikat digital yang berisi public key dan metadata (issuer, subject, periode berlaku), digunakan dalam TLS/SSL untuk enkripsi dan autentikasi.

268. **TLS Handshake**
     Proses negosiasi protokol keamanan antara klien dan server untuk menyepakati algoritma enkripsi, verifikasi sertifikat, dan pertukaran kunci enkripsi.

269. **Responsive Design**
     Pendekatan desain web yang memastikan tampilan dan tata letak halaman menyesuaikan secara mulus pada berbagai ukuran layar dan perangkat.

270. **Mobile-First Design**
     Metode desain yang memulai pengembangan antarmuka dari tampilan mobile (keterbatasan layar), kemudian bertahap menyesuaikan untuk tampilan desktop.

271. **Accessibility (a11y)**
     Praktik desain dan pengembangan agar aplikasi atau situs web dapat digunakan oleh semua orang, termasuk pengguna dengan disabilitas. Standar mencakup WCAG (Web Content Accessibility Guidelines).

272. **Internationalization (i18n) vs Localization (l10n)**
     \- _Internationalization_: mempersiapkan perangkat lunak agar mudah diterjemahkan atau disesuaikan untuk berbagai bahasa dan budaya tanpa mengubah kode.
     \- _Localization_: proses menerjemahkan dan menyesuaikan konten, format tanggal/waktu, dan elemen lain agar cocok dengan bahasa dan budaya target.

273. **Search Engine Optimization (SEO)**
     Serangkaian teknik dan praktik untuk meningkatkan peringkat dan visibilitas situs web pada halaman hasil mesin pencari (SERP), mencakup penggunaan kata kunci, struktur HTML semantik, dan kecepatan muat halaman.

274. **Feature Flag vs. Dark Launch**
     \- _Feature Flag_: sama dengan Feature Toggle—mengaktifkan/mematikan fitur pada runtime.
     \- _Dark Launch_: penerapan fitur baru di produksi tanpa mengeksposnya ke pengguna; biasanya dikombinasikan dengan flag untuk uji coba terbatas.

275. **GraphQL Schema Definition Language (SDL)**
     Bahasa deklaratif untuk mendefinisikan tipe, query, mutation, dan subscription dalam API GraphQL, memfasilitasi generasi dokumentasi dan validasi skema.

276. **Data Transfer Object (DTO)**
     Objek sederhana tanpa logika bisnis yang digunakan untuk mentransfer data antar lapisan aplikasi atau layanan, meminimalkan ketergantungan dan overhead serialisasi.

277. **Backbone Model–View–Controller (MVC) vs Model–View–Presenter (MVP)**
     \- _MVC_: pemisahan menjadi Model (data), View (antarmuka), Controller (logika).
     \- _MVP_: Model (data), View (antarmuka), Presenter (mengelola interaksi dan memperbarui View), memudahkan pengujian unit antarmuka.

278. **Server Push**
     Fitur HTTP/2 dan HTTP/3 di mana server dapat mengirimkan sumber daya ke klien sebelum diminta, mempercepat waktu muat halaman.

279. **Edge Caching**
     Penyimpanan konten statis atau precomputed di node edge CDN agar permintaan pengguna dilayani dari lokasi terdekat, mengurangi latensi dan beban origin.

280. **Zero Downtime Deployment**
     Strategi rilis di mana versi baru aplikasi diperkenalkan tanpa menghentikan layanan, menggunakan teknik seperti rolling update, blue–green deployment, atau canary release.
281. **OAuth 2.0**
     Kerangka kerja otorisasi terbuka yang memungkinkan aplikasi pihak ketiga memperoleh akses terbatas ke sumber daya HTTP atas nama pengguna, melalui pemberian token akses tanpa perlu berbagi kredensial utama.

282. **OpenID Connect (OIDC)**
     Lapisan identitas di atas OAuth 2.0 yang menambahkan autentikasi terstandar melalui token ID (JWT), memungkinkan “single sign-on” dan verifikasi identitas pengguna.

283. **HATEOAS (Hypermedia As The Engine Of Application State)**
     Komponen REST yang menyatakan bahwa klien berinteraksi dengan API sepenuhnya melalui link hypermedia yang diterima dalam respons, meminimalkan ketergantungan pada dokumentasi eksternal.

284. **GraphQL Subscription**
     Fitur dalam GraphQL untuk mendukung komunikasi real-time, di mana klien berlangganan pada update data melalui saluran WebSocket atau protokol serupa.

285. **Strangler Fig Pattern**
     Strategi migrasi aplikasi monolitik ke arsitektur mikroservis dengan cara membangun modul baru di sisi dan secara bertahap—seperti tumbuhan parasit “strangler fig”—menggantikan fungsionalitas lama hingga monolit sepenuhnya terdekomisioning.

286. **Saga Pattern**
     Pola manajemen transaksi terdistribusi dalam mikroservis, menggunakan serangkaian langkah lokal yang dapat di-rollback (kompensasi) untuk mempertahankan konsistensi data tanpa penguncian global.

287. **Horizontal Scaling (Scale-Out)**
     Proses menambah jumlah node/machine dalam klaster untuk menangani beban lebih besar, memperbaiki throughput dan toleransi kegagalan.

288. **Vertical Scaling (Scale-Up)**
     Proses meningkatkan kapasitas satu node/machine (CPU, memori, disk) untuk menangani beban lebih besar, tanpa menambah jumlah server.

289. **Elasticity**
     Kemampuan sistem cloud untuk secara otomatis menyesuaikan (menambah atau mengurangi) sumber daya sesuai beban kerja nyata tanpa intervensi manusia.

290. **High Availability (HA)**
     Desain sistem dan infrastruktur untuk meminimalkan downtime dengan replikasi, cluster, dan failover otomatis, sering diukur sebagai persentase “uptime” per tahun.

291. **Disaster Recovery (DR)**
     Rencana, prosedur, dan infrastruktur untuk memulihkan aplikasi dan data setelah kejadian bencana (kegagalan total, bencana alam), mencakup strategi cadangan, RTO, dan RPO.

292. **Recovery Point Objective (RPO)**
     Batas maksimum toleransi kehilangan data yang diizinkan selama pemulihan, dinyatakan sebagai interval waktu (mis. snapshot setiap 15 menit).

293. **Recovery Time Objective (RTO)**
     Batas waktu maksimum yang dibutuhkan untuk memulihkan layanan setelah gangguan hingga kembali ke kondisi operasional normal.

294. **Synthetic Monitoring**
     Teknik memantau ketersediaan dan performa aplikasi dengan menggunakan skrip otomatis yang melakukan simulasi transaksi pengguna secara periodik dari lokasi berbeda.

295. **Chaos Monkey**
     Alat dari Netflix untuk menerapkan prinsip Chaos Engineering dengan mematikan secara acak instance produksi, memverifikasi toleransi kegagalan dan self-healing.

296. **Strimzi / Kafka Streams**
     Framework di atas Apache Kafka untuk memproses dan mengubah data streaming secara real-time, mendukung operasi seperti filter, agregasi, dan `join`.

297. **Bulk Operations**
     Teknik melakukan sejumlah besar operasi baca/tulis (database, REST API, message queue) dalam satu batch untuk meningkatkan efisiensi dan mengurangi latensi per-item.

298. **SQL Window Functions**
     Fungsi analitik di SQL (mis. `ROW_NUMBER()`, `RANK()`, `SUM() OVER (…)`) yang menghitung agregasi atau peringkat dalam “jendela” baris terkait tanpa gruping global.

299. **Common Table Expression (CTE)**
     Fitur SQL (`WITH … AS (…)`) yang mendefinisikan subquery bernama untuk digunakan berulang dalam satu perintah, meningkatkan keterbacaan dan modularitas kueri.

300. **Data Mesh**
     Arsitektur terdistribusi untuk data analytics di mana domain bisnis masing-masing mengelola “domain data product” mereka sendiri, dengan tata kelola terpusat minimal untuk interoperabilitas.

301. **Lexical Analysis**
     Tahap awal dalam proses kompilasi atau interpretasi, di mana teks sumber dipecah menjadi token (kata kunci, identifier, literal, operator) melalui penganalisis leksikal (lexer).

302. **Parsing**
     Proses membangun struktur data hierarkis (parse tree atau syntactic tree) dari urutan token berdasarkan aturan tata bahasa (grammar) bahasa pemrograman, biasanya menggunakan parser LL atau LR.

303. **Abstract Syntax Tree (AST)**
     Representasi pohon abstrak dari struktur sintaksis program di mana node merepresentasikan konstruksi bahasa (ekspresi, pernyataan), tanpa detail tata letak atau token literal.

304. **Static Single Assignment (SSA) Form**
     Bentuk intermediate representation di mana setiap variabel diinisialisasi tepat sekali, memudahkan analisis data flow dan optimasi compiler.

305. **Control Flow Graph (CFG)**
     Model graf berarah yang menggambarkan alur eksekusi program, dengan simpul mewakili _basic block_ dan tepi mewakili lompatan kendali (branch, loop).

306. **Basic Block**
     Sekuen instruksi program yang dieksekusi secara berurutan tanpa lompatan masuk atau keluar di tengah; unit atomik untuk analisis dan optimasi di compiler.

307. **Optimization Pass**
     Tahap dalam pipeline compiler yang menerapkan transformasi pada IR (mis. constant folding, dead code elimination) untuk meningkatkan performa atau mengurangi ukuran.

308. **Peephole Optimization**
     Teknik optimasi di level instruksi akhir, memeriksa window kecil (“peephole”) kode mesin untuk menggantinya dengan instruksi yang lebih efisien.

309. **Tail Call Optimization**
     Transformasi pada pemanggilan fungsi rekursif posisi akhir (tail call) sehingga pemanggilan ulang tidak menambah frame baru di stack, menghindari _stack overflow_.

310. **Graph Database**
     Basis data NoSQL yang menyimpan dan memodelkan data sebagai graf (simpul dan relasi), cocok untuk analisis jaringan, rekomendasi, dan penelusuran konektivitas (mis. Neo4j).

311. **Lambda Architecture**
     Arsitektur data yang menggabungkan _batch processing_ (untuk akurasi tinggi) dan _stream processing_ (untuk latensi rendah) dalam tiga layer: batch, speed, dan serving.

312. **Polyglot Persistence**
     Pendekatan menggunakan beberapa jenis basis data (relasional, dokumen, grafik, kolom) dalam satu sistem sesuai kebutuhan akses dan karakteristik data masing-masing.

313. **Materialized View**
     Salinan fisik hasil kueri basis data yang di-refresh secara periodik, mempercepat pembacaan kueri kompleks dengan biaya penyimpanan dan pemeliharaan.

314. **Event-Driven Architecture**
     Paradigma arsitektur di mana komponen berkomunikasi melalui penerbitan dan konsumsi peristiwa (events), mendukung loose coupling dan skalabilitas real-time.

315. **Server-Sent Events (SSE)**
     Teknologi web di mana server dapat mengirim aliran data satu arah (stream) ke klien melalui koneksi HTTP yang terbuka, ideal untuk update realtime ringan.

316. **Message Broker**
     Komponen perantara yang menangani routing, penyimpanan, dan pengantaran pesan antar aplikasi atau layanan (mis. RabbitMQ, Apache Kafka), menyediakan pola Pub/Sub dan antrian.

317. **Data Lakehouse**
     Arsitektur penyimpanan data yang menyatukan kemampuan _data lake_ (menyimpan data mentah beragam format) dengan _data warehouse_ (schema-on-write, performa kueri tinggi).

318. **Schema-on-Write**
     Strategi desain basis data di mana data divalidasi dan diubah ke format yang sesuai (schema) saat penulisan, memastikan konsistensi tetapi memperlambat proses tulis.

319. **Schema-on-Read**
     Pendekatan di mana data disimpan mentah tanpa skema ketat, kemudian skema diterapkan saat pembacaan kueri, memberikan fleksibilitas dan mengakomodasi variasi data.

320. **Service Level Indicator (SLI) & Service Level Objective (SLO)**
     \- _SLI_: metrik spesifik (latensi, error rate, throughput) yang mengukur performa layanan.
     \- _SLO_: target quantitatif untuk SLI (mis. latency ≤ 200 ms pada 99,9 % permintaan), dasar untuk SLA dan operasional SRE.

321. **Behavior-Driven Development (BDD)**
     Metode pengembangan perangkat lunak yang memperluas Test-Driven Development dengan mendefinisikan contoh perilaku sistem dalam bahasa alami yang dapat dipahami oleh pengembang, tester, dan pemangku kepentingan (mis. “Given–When–Then”).

322. **Mutation Testing**
     Teknik pengujian yang mengevaluasi efektivitas suite pengujian dengan menyuntikkan modifikasi kecil (mutasi) ke kode sumber dan memeriksa apakah pengujian dapat mendeteksi perubahan tersebut.

323. **Fuzz Testing (Fuzzing)**
     Metode keamanan dan keandalan di mana input acak atau semi-terstruktur dikirim ke aplikasi untuk menemukan kondisi crash, memory leak, atau celah keamanan.

324. **Pairwise Testing**
     Pendekatan pengujian yang mengurangi jumlah kombinasi input dengan memastikan setiap pasangan nilai parameter diuji setidaknya satu kali, mengoptimalkan cakupan pada interaksi dua-parameter.

325. **Spiral Model**
     Model pengembangan iteratif yang menggabungkan elemen Waterfall dengan manajemen risiko, di mana setiap putaran (spiral) mencakup perencanaan, analisis risiko, rekayasa, dan evaluasi pelanggan.

326. **Rapid Application Development (RAD)**
     Pendekatan pengembangan yang menekankan prototyping cepat, feedback pengguna berkelanjutan, dan pengiriman modul fungsional dalam waktu singkat daripada proses dokumentasi yang panjang.

327. **Integrated Development Environment (IDE)**
     Aplikasi terpadu yang menyediakan editor kode, debugger, compiler/interpreter, dan alat bantu (linting, manajemen proyek) dalam satu paket untuk mempercepat siklus pengembangan.

328. **Long-Term Support (LTS)**
     Versi perangkat lunak atau pustaka yang dijamin mendapatkan pemeliharaan, perbaikan bug, dan patch keamanan dalam jangka waktu lebih lama dibandingkan rilis reguler.

329. **Kernel Space vs. User Space**
     \- _Kernel Space_: area memori di mana kode kernel dijalankan dengan hak istimewa penuh.
     \- _User Space_: area memori untuk aplikasi biasa dengan hak terbatas, berkomunikasi ke kernel melalui sistem panggilan (system calls).

330. **System Call**
     Mekanisme antarmuka antara program pengguna (user-space) dan kernel untuk meminta layanan (I/O, manajemen proses, alokasi memori) dengan beralih ke mode kernel.

331. **Interrupt**
     Sinyal hardware atau software yang menghentikan alur eksekusi normal CPU untuk menangani peristiwa segera (timer, I/O), lalu melanjutkan eksekusi sebelumnya setelah penanganan.

332. **Context Switch**
     Proses menyimpan dan memulihkan keadaan CPU (register, program counter, stack pointer) saat berpindah dari satu proses atau thread ke yang lain, memungkinkan multitasking.

333. **Preemptive vs. Cooperative Multitasking**
     \- _Preemptive_: scheduler sistem operasi memaksa penghentian thread/process setelah kuanta waktu tertentu atau prioritas lebih tinggi muncul.
     \- _Cooperative_: thread/process menyerahkan kendali secara sukarela setelah menyelesaikan tugas tertentu.

334. **Reentrant Function**
     Fungsi yang dapat dipanggil kembali (recursively atau oleh interrupt) tanpa risiko kondisi balapan karena tidak menggunakan atau memodifikasi state global, dan hanya bergantung pada parameter atau variabel lokal.

335. **Dynamic Dispatch**
     Mekanisme runtime untuk memilih implementasi metode atau fungsi berdasarkan tipe objek sebenarnya, biasanya melalui tabel virtual (vtable) di bahasa berorientasi objek.

336. **Virtual Method Table (vtable)**
     Struktur data di memori yang digunakan oleh bahasa berorientasi objek untuk menghubungkan panggilan metode virtual pada objek dengan implementasi spesifik kelasnya.

337. **Compile-Time vs. Run-Time Error**
     \- _Compile-Time Error_: kesalahan sintaks atau tipe yang terdeteksi saat kompilasi, mencegah pembuatan biner.
     \- _Run-Time Error_: kesalahan yang terjadi saat program berjalan (exceptions, segmentation fault), memerlukan penanganan atau debugging.

338. **Race Condition**
     Kondisi di mana dua atau lebih thread/process mengakses dan memodifikasi shared data secara bersamaan, menghasilkan perilaku tidak terduga jika tidak disinkronisasi dengan benar.

339. **Data Race**
     Spesialisasi race condition yang terjadi ketika dua thread melakukan operasi baca/tulis pada lokasi memori yang sama tanpa mekanisme sinkronisasi, dan setidaknya satu operasi adalah penulisan.

340. **Function Overloading vs. Overriding**
     \- _Overloading_: mendefinisikan beberapa fungsi atau metode dengan nama sama tetapi tanda tangan (tipe atau jumlah parameter) berbeda dalam satu lingkup.
     \- _Overriding_: subclass menyediakan implementasi baru untuk metode yang telah didefinisikan di superclass dengan tanda tangan identik.

341. **Constructor**
     Metode khusus dalam kelas yang dipanggil saat objek dibuat, bertugas menginisialisasi state awal objek.

342. **Destructor**
     Metode khusus dalam kelas (atau cleanup callback) yang dipanggil saat objek dihancurkan atau keluar scope, bertugas melepaskan sumber daya yang dimiliki objek (mis. file handle, memori).

343. **RAII (Resource Acquisition Is Initialization)**
     Pola manajemen sumber daya di C++ dan bahasa serupa di mana alokasi sumber daya dilakukan dalam constructor dan dilepaskan dalam destructor, memastikan tidak ada kebocoran saat exception terjadi.

344. **Virtualization**
     Teknologi yang memisahkan abstraksi perangkat keras dari sistem operasi sehingga beberapa instance VM dapat berjalan pada satu host fisik, masing-masing dengan OS dan lingkungan terisolasi.

345. **Hypervisor**
     Lapisan perangkat lunak yang mengelola dan menjalankan mesin virtual:
     \- _Type 1 (bare metal)_: berjalan langsung di atas perangkat keras (mis. VMware ESXi, Microsoft Hyper-V).
     \- _Type 2 (hosted)_: berjalan di atas sistem operasi host (mis. VirtualBox, VMware Workstation).

346. **Snapshot (Virtual Machine)**
     Salinan keadaan lengkap VM (memori, disk, konfigurasi) pada satu titik waktu, memungkinkan rollback cepat atau cloning instan untuk pengujian dan pemeliharaan.

347. **Sidecar Pattern**
     Pola arsitektur mikroservis di mana layanan pendukung (logging, proxy, konfigurasi) dijalankan sebagai kontainer terpisah dalam pod yang sama, menambah fungsionalitas tanpa mengubah kode utama.

348. **Service Registry**
     Komponen infrastruktur yang menyimpan metadata alamat (URI, port) dan status instans layanan mikro, memungkinkan discovery dinamis oleh klien atau API gateway (mis. Consul, Eureka).

349. **Consensus Algorithm**
     Protokol dalam sistem terdistribusi yang memastikan bahwa semua node setuju pada satu nilai atau urutan peristiwa meski terjadi kegagalan atau partisi—contoh: Raft, Paxos.

350. **Leader Election**
     Proses dalam konsensus untuk menunjuk satu node sebagai koordinator (leader) yang bertanggung jawab atas penulisan log atau penerimaan permintaan, menjamin konsistensi dan ketersediaan dalam klaster terdistribusi.

351. **Byzantine Fault Tolerance (BFT)**
     Kemampuan suatu sistem terdistribusi untuk mencapai konsensus meski beberapa node berperilaku arbitrer atau bermusuhan (faults “Byzantine”). Contoh: Practical Byzantine Fault Tolerance (PBFT).

352. **Eventual Consistency**
     Model konsistensi di sistem terdistribusi di mana update disebarkan secara asinkron, dan semua replika akan mencapai keadaan konsisten pada akhirnya, tanpa menjamin konsistensi segera setelah penulisan.

353. **Strong Consistency**
     Jaminan bahwa setiap pembacaan terbaru akan melihat penulisan paling mutakhir dalam sistem terdistribusi, biasanya memerlukan penguncian global atau koordinasi sinkron.

354. **Two-Phase Commit (2PC)**
     Protokol atomik transaksi terdistribusi di mana koordinator meminta persetujuan (“prepare”) dari semua peserta sebelum melakukan komit (“commit”) atau rollback.

355. **Three-Phase Commit (3PC)**
     Penyempurnaan 2PC dengan tiga tahap (canCommit, preCommit, doCommit) untuk mengurangi risiko blocking jika koordinator gagal di tengah proses, meski tidak sepenuhnya toleran partisi.

356. **Gossip Protocol**
     Mekanisme penyebaran informasi (state, konfigurasi, heartbeat) di klaster terdistribusi melalui pertukaran “lisan” antar node secara acak, meningkatkan skalabilitas dan toleransi kesalahan.

357. **Vector Clock**
     Struktur data untuk melacak urutan relatif kejadian antar node di sistem terdistribusi, menggunakan vektor timestamp per node sehingga deteksi konflik penulisan menjadi mungkin.

358. **Lamport Timestamp**
     Skema penomoran logis (scalar clock) untuk menetapkan urutan total peristiwa di sistem terdistribusi berdasarkan prinsip “happened-before” tanpa memerlukan sinkronisasi waktu nyata.

359. **Paxos**
     Keluarga algoritma konsensus yang menjamin keamanan dan liveness di sistem terdistribusi asalkan mayoritas node beroperasi, meski rancu dan sulit diimplementasikan secara langsung.

360. **CRDT (Conflict-free Replicated Data Type)**
     Struktur data terdistribusi yang mendukung replikasi asinkron dan menyelesaikan konflik otomatis tanpa koordinasi, menjamin convergensi deterministik di semua replika.

361. **Exponential Backoff**
     Algoritma retry yang menunda ulang permintaan yang gagal dengan interval yang meningkat secara eksponensial (mis. 1s, 2s, 4s, 8s) hingga batas maksimum untuk mengurangi beban dan kontensi pada sistem.

362. **Token Bucket Algorithm**
     Mekanisme pengaturan aliran (rate limiting) di jaringan atau API, di mana token dihasilkan pada kecepatan konstan ke “ember” dan setiap permintaan mengambil sejumlah token; permintaan tanpa token ditunda atau ditolak.

363. **Leaky Bucket Algorithm**
     Pendekatan rate limiting lain yang memproses permintaan pada laju tetap—permintaan yang datang lebih cepat dari laju ini akan ditampung dalam buffer (bucket) dan dapat terbuang jika penuh.

364. **Thundering Herd Problem**
     Situasi di mana banyak proses atau thread terbangun sekaligus (mis. setelah timeout atau notifikasi) untuk mengakses sumber daya terbatas, menyebabkan lonjakan beban dan degradasi performa.

365. **Time-To-Live (TTL)**
     Parameter yang menentukan umur maksimum suatu entri (cache, DNS record, message) dalam satuan waktu sebelum dianggap kadaluwarsa dan dihapus atau direfresh.

366. **Heartbeat Mechanism**
     Sinyal periodik yang dikirim oleh komponen (node, layanan) untuk menginformasikan status “hidup” kepada sistem monitoring atau cluster manager.

367. **Quorum**
     Jumlah minimum node atau partisipan dalam sistem terdistribusi yang diperlukan untuk membuat keputusan konsensus yang valid dan mencegah split-brain.

368. **Lambda Calculus**
     Model komputasi matematis yang mendasari banyak konsep pemrograman fungsional, berdasarkan abstraction (λx.E) dan application (E₁ E₂).

369. **Type Theory**
     Studi formal tentang sistem tipe yang mendasari bahasa pemrograman dan logika, berfokus pada konstruksi dan aturan inferensi tipe.

370. **Dependent Type**
     Sistem tipe di mana tipe dapat bergantung pada nilai; memungkinkan ekspresi properti program langsung di tipe (mis. vektor dengan panjang tipe-aman).

371. **Refinement Type**
     Tipe yang diperkaya dengan predikat logika untuk membatasi nilai yang diizinkan (mis. `{n: Int | n > 0}`), memfasilitasi verifikasi statis lebih canggih.

372. **Gradual Typing**
     Pendekatan hibrida antara static typing dan dynamic typing di mana bagian kode dapat diberi anotasi tipe statis sementara sisanya tetap dinamis, memungkinkan migrasi bertahap.

373. **Monad**
     Abstraksi fungsional untuk urutan komputasi dengan konteks (mis. `Maybe`, `IO`), mendefinisikan operasi `bind` (>>=) dan `return` sesuai hukum monad.

374. **Functor**
     Struktur data parametrik yang mendukung operasi `map`, menerapkan fungsi ke setiap elemen di dalam konteks (mis. `List`, `Option`).

375. **Category Theory**
     Cabang matematika yang mempelajari struktur dan hubungan abstrak antar objek dan morfisme, sering menjadi dasar teori untuk monad, functor, dan komposisi.

376. **Algebraic Data Type (ADT)**
     Kombinasi tipe dasar menggunakan konstruktor `sum` (union) dan `product` (tuple/record), memungkinkan definisi tipe kompleks secara deklaratif (mis. `data Maybe a = Nothing | Just a`).

377. **Pattern Matching**
     Ekspresi kontrol alur di banyak bahasa fungsional dan modern, yang membongkar dan mencocokkan struktur data sesuai pola tertentu.

378. **Continuation**
     Representasi eksplisit dari “sisa komputasi” pada suatu titik dalam program, yang dapat dipanggil ulang atau dimanipulasi.

379. **Continuation-Passing Style (CPS)**
     Gaya penulisan kode di mana kontrol dialihkan secara eksplisit melalui penerusan continuation sebagai parameter fungsi.

380. **Trampolining**
     Teknik untuk menghindari _stack overflow_ pada rekursi ekstensif dengan memecah panggilan fungsi menjadi langkah-langkah yang dikembalikan sebagai nilai dan dieksekusi dalam loop.

381. **Escape Analysis**
     Optimasi compiler atau runtime yang menentukan apakah objek dapat dialokasikan di stack daripada heap, mengurangi tekanan garbage collector.

382. **Inline Caching**
     Teknik optimasi runtime di mesin virtual dinamis yang menyimpan hasil resolusi metode atau properti di lokasi panggilan untuk percepatan pada pemanggilan berikutnya.

383. **Polymorphic Inline Cache (PIC)**
     Ekstensi inline caching yang mendukung beberapa tipe objek di satu lokasi panggilan, mengakumulasi cache entry untuk setiap bentuk objek.

384. **Tiered Compilation**
     Pendekatan JIT yang menggabungkan beberapa level kompilasi—kompilasi cepat pada awal dan optimasi lebih agresif setelah profil runtime terkumpul.

385. **Profile-Guided Optimization (PGO)**
     Teknik build-time yang menggunakan data profil eksekusi nyata untuk mengarahkan optimasi (mis. inlining, layout fungsi) agar menghasilkan performa lebih baik.

386. **Link-Time Optimization (LTO)**
     Optimasi yang terjadi pada tahap linking yang melihat keseluruhan hasil kompilasi modul untuk melakukan optimasi global seperti cross-module inlining.

387. **Feedback-Directed Optimization (FDO)**
     Sinonim PGO; optimasi berbasis umpan balik profil runtime yang digunakan compiler untuk membentuk keputusan optimasi.

388. **Bytecode Interpreter**
     Mesin virtual yang mengeksekusi instruksi bytecode (mis. JVM, CLR) satu per satu, sering kali dioptimasi dengan teknik threading untuk kecepatan lebih tinggi.

389. **Direct Threading**
     Skema implementasi interpreter di mana setiap bytecode mengandung alamat langsung dari fungsi handler, mengurangi overhead dispatch.

390. **Indirect Threading**
     Varian threading interpreter di mana bytecode berisi indeks ke tabel handler, sedikit lebih fleksibel namun dengan overhead lookup.

391. **Hotspot Compilation**
     Mekanisme runtime (mis. HotSpot JVM) yang mendeteksi _hot spots_ (kode yang sering dijalankan) dan menerapkannya dengan kompiler JIT tingkat tinggi.

392. **Generational Garbage Collection**
     Pendekatan GC yang memisahkan objek berdasarkan umur (young, old generation), mengoptimalkan kebanyakan objek yang cepat mati pada GC minor.

393. **Mark-Compact GC**
     Algoritma tracing collector yang menandai objek hidup, lalu memadatkan (compact) memori dengan memindahkan objek untuk menghilangkan fragmentasi.

394. **Copying Collector**
     GC yang membagi heap menjadi dua semi-space; pada setiap siklus, objek hidup disalin dari satu semi-space ke semi-space lainnya, mengatur fragmentasi otomatis.

395. **Weak Reference**
     Referensi yang tidak mencegah objek dari dikumpulkan oleh GC; apabila hanya ada referensi lemah, objek bisa dihapus saat koleksi berikutnya.

396. **Finalizer**
     Metode atau callback yang dijalankan sebelum objek dihancurkan oleh GC, untuk membersihkan sumber daya native—meski penggunaannya sering dihindari karena nondeterministik.

397. **Write Barrier**
     Mekanisme runtime yang melacak penulisan pointer antar generasi memori untuk mempertahankan invariant GC incremental atau generational.

398. **Read Barrier**
     Mekanisme yang dijalankan saat membaca pointer objek untuk mendukung GC concurrent atau incremental, menjaga konsistensi heap saat koleksi berjalan.

399. **Address Space Layout Randomization (ASLR)**
     Teknik keamanan OS yang menyebar acak posisi segmen memori (code, heap, stack) pada setiap eksekusi untuk mencegah prediksi alamat eksploitasi.

400. **Data Execution Prevention (DEP)**
     Fitur keamanan yang menandai segmen memori non-eksekusi (data) sehingga CPU menolak instruksi yang mencoba mengeksekusi dari area yang tidak diizinkan.
401. **Stack Unwinding**
     Proses otomatis pada penanganan _exception_ di mana stack frame dibersihkan (destructor dipanggil, resources dilepaskan) hingga ditemukan _handler_ yang sesuai atau program dihentikan.

402. **Heap Fragmentation**
     Kondisi di mana alokasi dan dealokasi memori dinamis menyebabkan ruang heap terpecah-pecah menjadi blok kecil tak terpakai, mengurangi efisiensi penggunaan memori.

403. **Memory Alignment**
     Penempatan data pada alamat memori yang merupakan kelipatan batas (alignment boundary) tertentu untuk mempercepat akses CPU dan mencegah _bus error_.

404. **Cache Miss (L1/L2/L3)**
     Kejadian ketika data yang dibutuhkan CPU tidak ditemukan di cache level-1, sehingga permintaan diteruskan ke cache level berikutnya atau memori utama, berdampak pada latensi.

405. **TLB (Translation Lookaside Buffer)**
     Cache kecil pada CPU yang menyimpan entri pemetaan alamat virtual-ke-fisik, mempercepat translasi alamat tanpa mengakses page table di memori utama.

406. **Software Transactional Memory (STM)**
     Abstraksi sinkronisasi di mana blok kode dieksekusi dalam “transaksi” memori: perubahan di-_buffer_ lalu di-_commit_ atomik jika tidak ada konflik.

407. **Lock Striping**
     Teknik meningkatkan paralelisme dengan membagi satu struktur data besar menjadi beberapa segmen, masing-masing dilindungi oleh kunci tersendiri, mengurangi kontensi.

408. **NUMA (Non-Uniform Memory Access)**
     Arsitektur memori di multiprosesor di mana waktu akses memori bergantung pada lokasi fisik modul memori relatif terhadap CPU, perlu penempatan data-aware.

409. **Speculative Parallelization**
     Pendekatan kompilasi/runtime yang mengeksekusi bagian kode sebagai tugas paralel berdasarkan prediksi non-bergantung, dengan rollback bila diprediksi salah.

410. **Profile-Driven Development**
     Praktik pengembangan yang mengintegrasikan data profil performa nyata (profil eksekusi) ke dalam proses desain dan optimasi, memprioritaskan usaha pada _hot spot_.

411. **Visitor Pattern**
     Pola perilaku (behavioral) di mana operasi pada elemen struktur objek dienkapsulasi dalam objek “visitor” terpisah, memungkinkan penambahan operasi baru tanpa memodifikasi kelas elemen.

412. **Memento Pattern**
     Pola perilaku yang memungkinkan penyimpanan dan pemulihan status internal objek tanpa melanggar enkapsulasi, dengan memisahkan objek “memento” yang merekam snapshot state.

413. **Prototype Pattern**
     Pola kreasi yang membuat objek baru dengan menyalin (“cloning”) instance prototipe, menghindari biaya inisialisasi kompleks pada konstruktor.

414. **Service Locator Pattern**
     Pola struktural untuk mengakses dependensi melalui registry sentral (service locator) yang menyediakan instans objek atau layanan berdasarkan tipe atau kunci.

415. **Shared Nothing Architecture**
     Arsitektur terdistribusi di mana setiap node memiliki storage dan compute sendiri tanpa berbagi memori atau disk, meningkatkan skalabilitas dan isolasi kegagalan.

416. **Virtual DOM**
     Representasi abstrak pohon elemen UI di memori yang digunakan oleh framework (React, Vue) untuk menghitung perubahan minimal dan memutakhirkan DOM nyata secara efisien.

417. **Shadow DOM**
     Mekanisme encapsulation pada Web Components yang memungkinkan elemen web memiliki subtree DOM terpisah dengan gaya dan skrip terisolasi.

418. **Hydration**
     Proses di mana markup HTML statis (hasil SSR/SSG) “diaktifkan” oleh JavaScript client-side untuk menjadi aplikasi interaktif, memasang event listener dan state.

419. **Data Binding**
     Teknik sinkronisasi otomatis antara model data aplikasi dan tampilan UI—bisa satu atau dua arah—untuk memudahkan pembaruan antarmuka saat data berubah.

420. **DevSecOps**
     Praktik integrasi keamanan (_security_) secara otomatis dalam _DevOps_ pipeline, menerapkan _shift-left_ testing dan _security-as-code_ untuk mendeteksi kerentanan sejak dini.

421. **Shift-Left Testing**
     Strategi memindahkan pengujian dan validasi ke tahap awal siklus pengembangan, mengurangi biaya perbaikan bug dengan deteksi dini (unit test, static analysis).

422. **Code Freeze**
     Titik dalam siklus rilis di mana perubahan kode baru dihentikan kecuali perbaikan bug kritis, stabilisasi versi final dan persiapan deployment.

423. **Bus Factor**
     Metode pengukuran risiko tim pengembang: jumlah minimum anggota tim yang jika “terhentikan” (mis. sakit, keluar) dapat mengganggu kelanjutan proyek.

424. **Brownfield Development**
     Pengembangan atau integrasi fitur baru pada sistem yang sudah ada, dengan tantangan adaptasi kode dan infrastruktur warisan.

425. **Greenfield Development**
     Pembangunan aplikasi atau sistem dari nol tanpa keterbatasan kode atau arsitektur sebelumnya, bebas menentukan teknologi dan struktur.

426. **Technical Spike**
     Eksperimen teknis singkat untuk mengevaluasi teknologi, pendekatan, atau kelayakan implementasi sebelum memulai pengembangan penuh.

427. **Feature Creep**
     Kondisi di mana lingkup proyek meluas tidak terkendali dengan penambahan fitur terus-menerus, mengancam jadwal, anggaran, dan kualitas.

428. **Canary Analysis**
     Proses evaluasi metrik dan telemetri pada subset kecil pengguna (canary release) untuk memverifikasi kualitas dan kinerja versi baru sebelum peluncuran penuh.

429. **Infrastructure as a Service (IaaS)**
     Model cloud di mana penyedia mengelola infrastruktur dasar (VM, jaringan, storage) dan pengguna bertanggung jawab atas OS, runtime, middleware, dan aplikasi.

430. **Platform as a Service (PaaS)**
     Model cloud yang menyediakan platform runtime dan middleware (database, framework, container orchestration), membebaskan pengguna dari manajemen infrastruktur dasar.

431. **Site Reliability Engineering (SRE)**
     Pendekatan rekayasa yang menggabungkan prinsip pengembangan perangkat lunak dengan operasional infrastruktur, bertujuan mencapai “reliability” tinggi melalui automasi, metrik SLI/SLO, dan eksperimen self-healing.

432. **Developer Experience (DX)**
     Kualitas keseluruhan interaksi pengembang dengan alat, API, dokumentasi, dan lingkungan kerja—mencakup kemudahan setup, kejelasan error, dan kecepatan umpan balik—untuk meningkatkan produktivitas dan kepuasan tim.

433. **GitOps**
     Metode pengelolaan infrastruktur dan aplikasi terotomasi dengan memanfaatkan Git sebagai “single source of truth”; setiap perubahan diterapkan ke cluster via pipeline otomatis yang mengawasi repositori Git.

434. **ChatOps**
     Praktik kolaborasi tim dan otomasi tugas devops melalui platform chat (Slack, Microsoft Teams), di mana perintah dan notifikasi diintegrasikan langsung ke saluran diskusi.

435. **Rolling Update**
     Strategi deployment di mana versi baru aplikasi digulirkan secara bertahap node demi node, memastikan sebagian instance terus melayani trafik selama proses upgrade dan memudahkan rollback secara selektif.

436. **A/B Testing**
     Metode eksperimental untuk membandingkan dua varian (A dan B) fitur atau antarmuka pengguna secara simultan pada segmen pengguna yang berbeda, guna menentukan versi dengan konversi atau metrik lain paling efektif.

437. **Kill Switch (Emergency Stop Pattern)**
     Mekanisme fail-safe untuk segera mematikan atau menonaktifkan fitur, layanan, atau sistem keseluruhan secara cepat apabila terjadi kondisi kritis atau perilaku abnormal di produksi.

438. **Warm Standby vs. Hot Standby**
     Dua opsi cadangan infrastruktur:
     \- _Warm Standby_: sistem cadangan dalam keadaan sebagian siap (terkonfigurasi dan ter‐sync data), membutuhkan waktu singkat untuk aktif penuh.
     \- _Hot Standby_: sistem cadangan aktif secara penuh dan siap mengambil alih secara instan tanpa penundaan.

439. **Dependency Graph**
     Representasi visual atau struktural yang menunjukkan ketergantungan antar modul, paket, atau layanan dalam suatu sistem, penting untuk memahami dampak perubahan dan mengelola versi.

440. **Transitive Dependency**
     Ketergantungan tidak langsung—misalnya, `A` bergantung pada `B` yang pada gilirannya bergantung pada `C`—yang dapat memperkenalkan risiko versi konflik dan security vulnerability jika tidak dikelola dengan baik.

441. **B-Tree**
     Struktur data pohon seimbang yang umum digunakan untuk indeks basis data dan sistem file, di mana setiap simpul dapat memiliki banyak anak, meminimalkan jumlah disk I/O untuk operasi pencarian, penyisipan, dan penghapusan.

442. **Write-Through vs Write-Back Caching**
     \- _Write-Through_: setiap penulisan ke cache langsung ditulis juga ke memori utama atau media penyimpanan, menjamin konsistensi namun dengan latensi lebih tinggi.
     \- _Write-Back_: penulisan pertama hanya menulis ke cache dan menunda penulisan ke memori utama hingga blok di-`evict`, mengurangi I/O namun memerlukan mekanisme write-back yang kompleks untuk menjaga keandalan.

443. **Read-Copy-Update (RCU)**
     Teknik sinkronisasi non-blocking pada kernel Linux dan sistem multithread di mana pembaca dapat membaca data tanpa kunci, sementara penulis menggandakan struktur, memperbarui copy, dan kemudian mengganti rujukan atomik, memaksimalkan performa baca.

444. **Reactive Streams**
     Spesifikasi untuk pemrosesan data asinkron berbasiskan aliran (“streams”) yang mendukung backpressure, dengan komponen standard seperti Publisher, Subscriber, Subscription, dan Processor untuk interoperabilitas di berbagai implementasi (Reactor, RxJava).

445. **Peer-to-Peer (P2P) Network**
     Arsitektur jaringan terdistribusi di mana setiap node bertindak sebagai client dan server secara bersamaan, berbagi sumber daya (file, komputasi) langsung tanpa perantara terpusat, populer dalam protokol berbagi berkas dan blockchain.

446. **Distributed Denial of Service (DDoS)**
     Serangan siber di mana penyerang menggunakan banyak sumber (botnet) untuk membanjiri server atau jaringan dengan lalu lintas palsu, menyebabkan layanan tidak tersedia bagi pengguna sah.

447. **Checksum vs Cyclic Redundancy Check (CRC)**
     \- _Checksum_: metode sederhana menjumlahkan nilai data untuk mendeteksi kesalahan transmisi, mudah diimplementasikan tapi rentan kolisi.
     \- _CRC_: algoritma polinomial yang menghasilkan nilai lebih kompleks untuk deteksi kesalahan yang lebih andal pada transmisi data dan penyimpanan.

448. **Idempotent HTTP Methods**
     Metode HTTP yang dapat dipanggil berulang kali dengan efek samping yang sama seperti satu kali—contoh: `GET`, `PUT`, `DELETE`—sangat penting bagi desain API yang dapat diulang (retry-safe).

449. **HMAC (Hash-based Message Authentication Code)**
     Mekanisme kriptografi yang menggabungkan hash kriptografis dengan kunci rahasia untuk memverifikasi integritas dan keaslian pesan, umum digunakan dalam protokol keamanan seperti TLS dan API signing.

450. **TLS Session Resumption**
     Fitur dalam TLS untuk mempercepat handshake selanjutnya dengan menggunakan session ID atau session ticket, mengurangi overhead kriptografi dan latensi pada koneksi berulangkali.

451. **Certificate Pinning**
     Teknik keamanan di mana aplikasi klien menyimpan (pin) fingerprint sertifikat server yang diharapkan, menolak koneksi TLS jika sertifikat berubah, mencegah serangan man-in-the-middle meski CA terkompromi.

452. **Service Discovery**
     Proses otomatis menemukan lokasi (IP, port) instans layanan dalam lingkungan dinamis (container, cloud), sehingga klien dapat terhubung tanpa konfigurasi statis.

453. **Health Check Endpoint**
     URL atau API khusus yang disediakan oleh layanan untuk melaporkan status operasional (up/down, degradasi) sehingga sistem orkestrasi atau load balancer dapat melakukan probe dan penjadwalan ulang.

454. **Side-Channel Attack**
     Serangan yang mengeksploitasi informasi implisit (waktu eksekusi, penggunaan daya, cache timing) untuk memperoleh data rahasia dari sistem kriptografi atau algoritma yang tampak aman.

455. **Homomorphic Encryption**
     Skema kriptografi yang memungkinkan operasi tertentu (penjumlahan, perkalian) dijalankan langsung pada data terenkripsi tanpa mendekripsi, menjaga kerahasiaan data selama pengolahan.

456. **Secure Enclave / Trusted Execution Environment (TEE)**
     Area terisolasi di prosesor (mis. Intel SGX, ARM TrustZone) yang menjalankan kode dan menyimpan data secara aman di luar jangkauan OS atau hypervisor yang tidak tepercaya.

457. **Oblique Strategies**
     Buku kartu berisi pertanyaan reflektif yang sering dipakai dalam desain dan pemecahan masalah kreatif—digunakan kadang-kadang secara metafora untuk menginspirasi strategi coding dan arsitektur.

458. **Chaos Toolkit**
     Framework open source untuk mendefinisikan, menjalankan, dan menganalisis eksperimen Chaos Engineering dengan format deklaratif dan integrasi ke toolchain CI/CD.

459. **Data Gravity**
     Konsep bahwa semakin besar volume data di suatu lokasi, semakin besar kecenderungan aplikasi dan layanan lain akan pindah atau berkumpul di dekat data tersebut karena latensi dan biaya transfer.

460. **Event Sourcing vs. Command Sourcing**
     \- _Event Sourcing_: menyimpan setiap perubahan state sebagai event yang dapat diputar ulang.
     \- _Command Sourcing_: menyimpan perintah (intent) yang dikirim ke sistem, dan menerapkannya ulang untuk membangun state.

461. **Bulkhead Isolation**
     Menerapkan batasan sumber daya (thread pool, connection pool) secara terpisah untuk tiap komponen atau layanan guna mencegah kegagalan satu layanan menurunkan layanan lain.

462. **AWS Lambda Layers**
     Fitur AWS Lambda untuk mengemas dan membagikan dependensi atau libraries di antara beberapa fungsi tanpa duplikasi paket, mempercepat deploy dan menghemat ruang.

463. **CloudFormation Drift Detection**
     Mekanisme AWS CloudFormation untuk mendeteksi perbedaan (drift) antara stack yang di-deploy dan definisi template asli, memungkinkan rekonsiliasi infrastruktur as code.

464. **Terraform State Backend**
     Penyimpanan terpusat untuk menyimpan file state Terraform (local, remote, S3, Consul) agar tim dapat berkolaborasi dan mengunci state untuk menghindari konflik.

465. **Immutable Data Structures**
     Struktur data yang tidak dapat diubah setelah dibuat; setiap “perubahan” menghasilkan instance baru, memudahkan pemrograman fungsional dan concurrency.

466. **Soft Real-Time vs. Hard Real-Time**
     \- _Soft Real-Time_: sistem di mana kegagalan memenuhi batas waktu diproses dapat ditoleransi sesekali.
     \- _Hard Real-Time_: kegagalan memenuhi tenggat waktu merupakan kegagalan kritis sistem (automotif, avionik).

467. **Time Series Database (TSDB)**
     Basis data yang dioptimalkan untuk menyimpan dan mengambil data time-series (metrik, log), dengan fitur kompresi temporal dan query window berbasis waktu (InfluxDB, Prometheus).

468. **Vector Search**
     Teknik pencarian berbasis embedding vektor (machine learning) untuk menemukan data semantik terdekat (similarity search) dalam ruang multidimensi, sering dipakai untuk rekomendasi dan retrieval AI.

469. **GraphQL Federation**
     Pola untuk membagi skema GraphQL menjadi beberapa layanan mikro yang menyusun satu endpoint federasi, mendukung komposisi skema dan lintas-layanan resolusi.

470. **WebRTC ICE (Interactive Connectivity Establishment)**
     Proses negosiasi jalur peer-to-peer di WebRTC yang mencoba candidate jaringan (host, STUN, TURN), firewall traversal, dan NAT negotiation untuk koneksi real-time.

471. **Outbox Pattern**
     Teknik memastikan transaksi atomik dalam sistem terdistribusi dengan menulis event ke tabel outbox dalam database yang sama dengan data bisnis, lalu mem-publish event secara terpisah.

472. **Change Data Capture (CDC)**
     Metode untuk melacak dan mengekstrak perubahan data (insert, update, delete) secara real-time dari basis data sumber (log, binlog) untuk replikasi atau pipeline data streaming.

473. **Circuit Breaker Metrics (Error Rate, Volume, Duration)**
     Parameter yang memicu open/close state pada pola Circuit Breaker, seperti persentase kesalahan, jumlah panggilan, dan durasi eksekusi yang gagal.

474. **Feature Store**
     Sistem penyimpanan terpadu untuk fitur data dalam machine learning, menyediakan layanan online/offline retrieval, versioning, dan governance fitur.

475. **Polyfill Service**
     Layanan web (seperti polyfill.io) yang secara dinamis menyajikan polyfill JavaScript hanya untuk fitur yang tidak didukung browser klien berdasarkan user-agent.

476. **Graceful Degradation**
     Strategi desain sistem yang memastikan tetap berfungsi pada fitur inti saat sebagian layanan atau komponen gagal, menurunkan kualitas layanan bukan kegagalan total.

477. **Backward Compatibility**
     Kemampuan sistem, API, atau data untuk menerima dan memproses input atau interaksi dari versi klien lama tanpa perubahan.

478. **Forward Compatibility**
     Desain sistem agar dapat mengabaikan elemen atau atribut baru yang tidak dikenali, memungkinkan klien lama berinteraksi dengan sistem versi lebih baru tanpa gagal.

479. **Dead Letter Queue (DLQ)**
     Antrian khusus dalam sistem pesan (message queue) tempat pesan yang gagal diproses berulang kali disimpan untuk pemeriksaan manual atau pemrosesan ulang terpisah.

480. **Kubernetes Operator Pattern**
     Pola pengemasan, penyebaran, dan pengelolaan aplikasi domain-spesifik di Kubernetes melalui Custom Resource Definitions (CRD) dan controller khusus (“operator”) yang mengotomatiskan tugas-tugas operasional.

481. **Optimistic Concurrency Control**
     Teknik manajemen akses bersamaan di basis data atau penyimpanan di mana setiap transaksi melanjutkan tanpa kunci, lalu memeriksa konflik pada saat komit dan membatalkan jika perlu.

482. **Pessimistic Concurrency Control**
     Pendekatan sinkronisasi di mana transaksi menahan kunci pada data yang akan diakses agar tidak terjadi konflik, memastikan konsistensi tetapi berpotensi menimbulkan bottleneck.

483. **Database Migration Tooling**
     Alat atau framework (mis. Flyway, Liquibase) yang mengelola versi skema basis data melalui skrip migrasi terurut, memfasilitasi penerapan dan rollback perubahan struktur data.

484. **Structured Logging**
     Praktik mencatat log dalam format terstruktur (JSON, XML) dengan metadata terdefinisi (timestamp, level, trace ID), memudahkan analisis, pencarian, dan korelasi di sistem terdistribusi.

485. **Safety Checks (Sanity Guards)**
     Pemeriksaan kondisi awal atau batas (assertions, guards) pada input, state, atau konfigurasi untuk mencegah eksekusi kode lebih lanjut jika terdeteksi kondisi yang tidak valid.

486. **[Regular Expression (Regex)][486]**
     Sintaksis untuk mendefinisikan pola pencarian dan transformasi teks, menggunakan metakarakter (mis. `^`, `*`, `?`, `[]`, `()`) untuk mencocokkan dan memanipulasi string.

487. **Backus–Naur Form (BNF)**
     Notasi formal untuk mendefinisikan tata bahasa (grammar) bahasa pemrograman atau format data secara rekursif, dengan aturan produksi berbentuk `<nonterminal> ::= ekspresi`.

488. **Extended Backus–Naur Form (EBNF)**
     Perluasan BNF yang menambahkan operator kuantifikasi (`?`, `*`, `+`), grup (`(...)`), dan alternatif (`|`) untuk menulis grammar dengan lebih ringkas.

489. **Syntax Highlighting**
     Fitur editor kode yang memberi warna berbeda pada elemen sintaks (kata kunci, literal, komentar) agar struktur kode lebih mudah dipahami dan kesalahan cepat terlihat.

490. **Code Folding**
     Kemampuan editor untuk menyembunyikan (collapse) dan menampilkan kembali (expand) blok kode atau komentar, membantu navigasi pada berkas panjang.

491. **Snippet**
     Potongan kode yang dapat di-_insert_ cepat di dalam editor melalui pintasan atau perintah, sering disertai tempat kursor berurutan (tab stops) untuk pengisian parameter.

492. **Emmet Abbreviation**
     Singkatan ekspansif di editor HTML/CSS (mis. `ul>li*5>a{Link}`) yang secara otomatis menghasilkan struktur tag lengkap untuk mempercepat penulisan markup.

493. **Template Engine**
     Perangkat lunak untuk menghasilkan teks (HTML, dokumen, kode) dengan me-_render_ template berisi placeholder dan logika minimal, mis. Handlebars, Jinja, Mustache.

494. **Preprocessor Directive**
     Instruksi khusus di awal baris pada bahasa yang mendukung pra-kompilasi (mis. `#include`, `#define` di C/C++), memengaruhi bagaimana sumber diubah sebelum kompilasi.

495. **Macro**
     Sekumpulan instruksi atau kode yang diberi nama dan dapat dipanggil untuk perluasan teks atau kompilasi—dapat berupa macro pra-kompilasi (C) atau macro runtime (Lisp).

496. **Unicode**
     Standar pengkodean karakter universal yang menyediakan kode unik untuk lebih dari 140.000 karakter dari berbagai sistem penulisan, simbol, dan emoji.

497. **ASCII (American Standard Code for Information Interchange)**
     Tabel pengkodean karakter 7-bit untuk huruf Latin dasar, angka, dan kontrol, mendasari banyak format teks dan protokol jaringan awal.

498. **UTF-8**
     Skema pengkodean Unicode yang menggunakan 1–4 byte per karakter, kompatibel dengan ASCII untuk byte < 0x80, banyak digunakan di web dan sistem file.

499. **LaTeX**
     Bahasa markup dan sistem typesetting untuk dokumen ilmiah dan teknis, menyediakan kontrol presisi tipografi dan paket untuk persamaan matematika, tabel, dan referensi otomatis.

500. **Markdown**
     Bahasa markup ringan untuk menulis dokumentasi dan teks kaya dengan sintaks yang mudah dibaca (mis. `#` untuk heading, `*` untuk daftar), sering dikonversi ke HTML.

501. **reStructuredText (reST)**
     Bahasa markup sederhana untuk dokumentasi Python (Sphinx), mendukung direktif, peran inline, dan referensi silang tanpa banyak tanda kurung.

502. **AsciiDoc**
     Bahasa markup mirip Markdown dengan fitur lanjutan (tabel, admonition, include), diubah menjadi HTML, PDF, atau dokumen lain via Asciidoctor.

503. **Docstring**
     Komentar terdokumentasi yang ditempatkan tepat di bawah deklarasi fungsi, kelas, atau modul—sering diekstrak oleh generator dokumentasi (Sphinx, Javadoc).

504. **Javadoc**
     Alat dan format komentar di Java untuk menghasilkan dokumentasi API dalam HTML, memproses tag seperti `@param`, `@return`, dan `@throws`.

505. **Swagger / OpenAPI Specification**
     Format terstandar (YAML/JSON) untuk mendeskripsikan RESTful API, mencakup endpoint, parameter, respons, dan model data, dapat digenerasi ke dokumentasi interaktif.

506. **RAML (RESTful API Modeling Language)**
     Bahasa YAML untuk memodelkan API REST, menekankan modularitas, reuse, dan dokumentasi terstruktur yang dapat digunakan untuk menghasilkan server stub dan klien.

507. **API Blueprint**
     Bahasa markup sederhana untuk merancang dan mendokumentasikan API HTTP, dengan fokus pada readability dan kemampuan diuji lewat **Drafter**.

508. **Pandoc**
     Alat konversi dokumen universal yang mentransformasikan antara format markup dan dokumen seperti Markdown, LaTeX, HTML, DOCX, dan EPUB.

509. **WYSIWYG Editor**
     “What You See Is What You Get” editor untuk konten web atau dokumen, menampilkan hasil akhir secara langsung (mis. TinyMCE, CKEditor).

510. **Autocomplete / IntelliSense**
     Fitur editor/IDE yang menampilkan saran kode berdasarkan konteks dan tipe data, termasuk nama variabel, metode, dan dokumentasi inline.

511. **Code Lens**
     Fitur editor (mis. VS Code) yang menampilkan informasi kontekstual (referensi, tes, perubahan Git) di atas definisi fungsi atau kelas, tanpa mengubah kode.

512. **Diff**
     Representasi perbedaan antara dua versi berkas teks, menunjukkan baris yang ditambahkan (`+`), dihapus (`–`), atau diubah, dasar untuk review dan patch.

513. **Patch**
     Sekumpulan perubahan yang diekspor dari diff dan dapat diterapkan ke kode basis dengan utilitas seperti `patch` atau `git apply`.

514. **Cherry-Pick**
     Operasi Git untuk menyalin commit spesifik dari satu branch ke branch lain tanpa menggabungkan seluruh riwayat.

515. **Rebase**
     Git operation untuk memindahkan atau menerapkan ulang serangkaian commit di atas basis branch baru, menciptakan riwayat linear dan memudahkan integrasi.

516. **Staging Area**
     Area sementara di Git di mana perubahan ditandai untuk dimasukkan ke commit berikutnya, memungkinkan pemilahan file dan bagian hunks sebelum melakukan commit.

517. **HEAD (Git)**
     Pointer dalam repositori Git yang menunjuk ke commit saat ini di branch aktif, dapat dialihkan untuk melihat commit lain atau detasemen.

518. **Git Blame**
     Perintah Git yang menampilkan informasi baris per baris dalam file, termasuk siapa yang terakhir mengubah dan pada commit apa, untuk membantu pelacakan sejarah.

519. **Git Bisect**
     Fitur Git untuk memudahkan debugging regresi dengan melakukan binary search di rentang commit, menandai setiap commit sebagai “good” atau “bad” hingga menemukan penyebab bug.

520. **Trunk-Based Development**
     Model branching di mana developer bekerja langsung di satu branch utama (“trunk”) dengan commit kecil dan sering, meminimalkan kompleksitas merge dan integrasi.

521. **Git Flow**
     Workflow branching populer yang membagi siklus rilis menjadi branch `feature/`, `develop`, `release/`, `hotfix/`, dan `master` untuk mengorganisir pengembangan dan rilis.

522. **Conventional Commits**
     Konvensi penamaan pesan commit yang terstruktur (`type(scope): subject`), memudahkan automasi changelog, versioning semantik, dan integrasi CI/CD.

523. **Commitizen**
     Alat CLI yang membimbing developer dalam membuat pesan commit sesuai format Conventional Commits, mengurangi kesalahan dan inkonsistensi.

524. **Semantic Release**
     Praktik otomatisasi versi dan publishing paket berdasarkan pesan commit dengan aturan semantik (`feat` naik minor, `fix` naik patch, `BREAKING CHANGE` naik major).

525. **Git Hooks**
     Skrip yang dijalankan secara otomatis sebelum atau setelah event Git (pre-commit, post-merge, pre-push), digunakan untuk linting, testing, atau validasi lain.

526. **Pre-commit Hook**
     Git hook yang dijalankan sebelum commit dibuat, biasanya memeriksa kode (linting, formatting) dan menolak commit jika syarat tidak terpenuhi.

527. **Continuous Integration Pipeline (CI Pipeline)**
     Rangkaian tahapan otomatis (build, test, lint, deploy) di setiap push atau pull request untuk memastikan kualitas kode dan kesiapan rilis.

528. **YAML Pipeline**
     Definisi CI/CD pipeline dalam format YAML yang dapat versioned bersama kode, memudahkan kolaborasi dan reproduksi alur build.

529. **JSON Schema**
     Spesifikasi untuk mendefinisikan struktur, tipe, dan constraint dokumen JSON, yang memungkinkan validasi data sebelum diproses aplikasi.

530. **XML Schema Definition (XSD)**
     Bahasa deklaratif untuk memodelkan dan memvalidasi struktur dokumen XML, menggantikan DTD dengan kemampuan tipe data dan namespace.

531. **Document Type Definition (DTD)**
     Format awal untuk mendefinisikan grammar dan elemen valid dalam dokumen XML/SGML, dengan sintaks berbasis deklarasi `<!ELEMENT>` dan `<!ATTLIST>`.

532. **Web Services Description Language (WSDL)**
     Bahasa berbasis XML untuk mendeskripsikan endpoint, operasi, dan pesan SOAP web service, memungkinkan klien untuk menghasilkan stub secara otomatis.

533. **API Contract**
     Kesepakatan formal yang menetapkan endpoint, metode, parameter, dan format respons antara penyedia dan konsumen API, menjadi dasar pengembangan dan pengujian.

534. **Contract-First Development**
     Pendekatan pembuatan API di mana skema atau spesifikasi (OpenAPI, WSDL) ditulis terlebih dahulu, kemudian kode stub dan implementasi dihasilkan darinya.

535. **Code-First Development**
     Metode di mana API atau model data dibuat langsung dalam kode, dan spesifikasi (OpenAPI, gRPC IDL) diekstraksi secara otomatis melalui tooling.

536. **Technical Writing**
     Disiplin penulisan dokumentasi teknis—API reference, tutorial, panduan—dengan fokus pada kejelasan, konsistensi, dan kebutuhan audiens teknis.

537. **Documentation Style Guide**
     Panduan tertulis yang menetapkan aturan penulisan (tone, terminologi, format) untuk materi dokumentasi agar konsisten dan mudah dipahami.

538. **Markdown Linting**
     Proses otomatis memeriksa file Markdown untuk kesalahan sintaks, style inconsistencies, atau struktur heading yang tidak sesuai panduan.

539. **README Template**
     Struktur dasar berkas README yang mencakup deskripsi proyek, instalasi, penggunaan, kontribusi, dan lisensi, memudahkan proyek baru memiliki dokumentasi standar.

540. **Cyclomatic Complexity**
     Metode pengukuran kompleksitas logika program dengan menghitung jumlah jalur eksekusi independen dalam fungsi atau modul, berguna untuk menilai kebutuhan pengujian.

541. **Halstead Metrics**
     Kumpulan metrik perangkat lunak berdasarkan jumlah operator dan operand dalam kode, menghasilkan ukuran seperti Volume, Difficulty, dan Effort untuk memperkirakan kualitas dan produktivitas.

542. **Anti-Pattern**
     Praktik desain atau implementasi yang umum dijumpai namun terbukti kontraproduktif—misalnya _Spaghetti Code_, _Cargo Cult Programming_, atau _Golden Hammer_.

543. **God Object**
     Anti-pattern di mana satu objek atau kelas mengelola terlalu banyak tanggung jawab dan data, melanggar prinsip Single Responsibility dan menyulitkan pemeliharaan.

544. **Mock / Stub / Spy / Fake**
     Objek pengganti yang digunakan dalam pengujian unit:
     \- _Mock_: memverifikasi interaksi (metode dipanggil dengan parameter tertentu).
     \- _Stub_: menyediakan data statis untuk alur pengujian.
     \- _Spy_: panggilan riwayat disimpan untuk verifikasi.
     \- _Fake_: implementasi ringan yang meniru perilaku nyata.

545. **Test Harness**
     Kerangka kerja atau rangkaian skrip dan utilitas yang memfasilitasi eksekusi, pelaporan, dan automasi suite pengujian.

546. **Dependency Injection Container (IoC Container)**
     Komponen runtime yang mengelola penyediaan dan siklus hidup objek berdasarkan konfigurasi, memudahkan penerapan Dependency Injection secara otomatis.

547. **Law of Demeter**
     Prinsip desain yang menyarankan bahwa suatu modul hanya boleh berkomunikasi dengan “teman dekat” (self, parameter, objek yang dibuat, objek koleksi), meminimalkan _coupling_.

548. **Composition over Inheritance**
     Pendekatan desain yang menganjurkan penggunaan agregasi dan pendelegasian (komposisi) untuk reuse kode alih-alih pewarisan, meningkatkan fleksibilitas dan modularitas.

549. **Bounded Context**
     Konsep dalam Domain-Driven Design yang memisahkan domain besar menjadi subdomain yang didefinisikan dengan jelas istilah dan modelnya sendiri, menghindari ambiguitas.

550. **Entity vs. Value Object**
     Dalam DDD:
     \- _Entity_: objek dengan identitas unik dan siklus hidup terpisah.
     \- _Value Object_: objek tanpa identitas, didefinisikan oleh nilainya dan bersifat immutable.

551. **Aggregate Root**
     Objek utama dalam satu _aggregate_ (kumpulan entitas dan value object) yang menjadi pintu akses tunggal untuk modifikasi struktur data, menjaga invariants konsisten.

552. **Callback Hell**
     Situasi di mana banyak callback bertumpuk di dalam callback lain (piramida fungsi), menyulitkan pembacaan dan penanganan error; biasa diatasi dengan Promises atau async/await.

553. **Fluent Interface / Fluent API**
     Gaya desain API di mana metode dipanggil berantai (method chaining) untuk membuat kode deklaratif dan mudah dibaca, sering dipakai dalam builder pattern.

554. **Builder Pattern**
     Pola kreasi yang memisahkan konstruksi objek kompleks menjadi beberapa langkah melalui objek _builder_, memungkinkan konfigurasi secara terpisah dan kode yang lebih bersih.

555. **Minimal Viable Product (MVP)**
     Versi paling sederhana dari produk yang menyertakan cukup fitur untuk memuaskan pengguna awal dan mendapatkan umpan balik, mempercepat validasi asumsi pasar.

556. **Wireframe vs Prototype**
     \- _Wireframe_: kerangka visual statis untuk tata letak antarmuka tanpa interaktivitas.
     \- _Prototype_: model interaktif yang meniru alur pengguna dan fungsi utama sebelum pengembangan penuh.

557. **DITA (Darwin Information Typing Architecture)**
     Standar XML untuk menulis dokumentasi modular dan reuse content, mendukung topik, peta, dan metadata terstruktur untuk publikasi terkontrol.

558. **Cognitive Load**
     Tingkat usaha mental yang dibutuhkan pengguna atau pengembang untuk memahami antarmuka, API, atau kode; desain sebaiknya meminimalkan beban ini untuk meningkatkan produktivitas.

559. **Documentation Style Guide**
     Panduan baku untuk konsistensi penulisan dokumentasi (penomoran, istilah, format kode, tone), memudahkan pembaca dan kolaborator mengikuti standar yang sama.

560. **Changelog vs Release Notes**
     \- _Changelog_: catatan teknis terstruktur tentang setiap perubahan kode (feature, fix, breaking).
     \- _Release Notes_: ringkasan perubahan dan dampaknya untuk pengguna akhir, berfokus pada fitur dan perbaikan penting.

561. **Semantic Diff**
     Teknik perbandingan kode yang mengevaluasi perubahan struktur atau logika di atas teks mentah, memfokuskan review pada semantik alih-alih format.

562. **Code Churn**
     Metri pengukuran jumlah kode yang diubah (ditambah, dihapus) dalam periode waktu tertentu, dapat menjadi indikator stabilitas dan kualitas modul.

563. **Code Freeze**
     (Kembali ditekankan untuk repositori) keadaan di mana perubahan fitur dibatasi dan hanya perbaikan bug kritis yang diizinkan, siap menuju rilis final.

564. **EditorConfig**
     Format file `.editorconfig` untuk menyelaraskan aturan gaya (indentasi, encoding, akhir baris) antar editor dan IDE, meminimalkan perbedaan lingkungan tim.

565. **Prettier / Black / Clang-Format**
     Formatter kode otomatis populer untuk berbagai bahasa (JavaScript, Python, C/C++), menerapkan aturan gaya konsisten sesuai konfigurasi tim.

566. **TOML (Tom’s Obvious, Minimal Language)**
     Bahasa konfigurasi yang bersifat human-readable dan mudah di-parse, dengan sintaks yang eksplisit untuk tipe data (string, integer, float, datetime, array, table) dan mendukung hierarki via tabel.

567. **INI File**
     Format teks sederhana untuk konfigurasi, menggunakan seksi `[header]` dan pasangan `key = value`; mudah dibaca dan didukung luas, tetapi tidak standar untuk tipe data kompleks.

568. **Environment Variable**
     Variabel sistem operasi yang tersedia untuk proses dan aplikasi, digunakan untuk mengonfigurasi perilaku runtime (jalur eksekusi, kredensial, mode debug) tanpa mengubah kode.

569. **Scaffolding**
     Proses otomatis pembuatan struktur dasar proyek (folder, file, dan kode boilerplate) menggunakan tool atau CLI framework, mempersingkat setup awal aplikasi.

570. **Yeoman**
     Generator scaffolding berbasis Node.js yang membantu memulai proyek web dengan template generator kustom, mengotomasi pembuatan struktur direktori dan instalasi dependensi.

571. **Cookiecutter**
     Tool generasi proyek templated berbasis Python yang menggunakan direktori template dan variabel Jinja untuk membuat kerangka proyek apa pun—backend, frontend, dokumentasi—dengan sekali perintah.

572. **Boilerplate Code**
     Blok kode yang dipakai berulang dalam banyak proyek dengan sedikit atau tanpa modifikasi; contohnya pengaturan koneksi database, konfigurasi logging, atau struktur REST controller.

573. **Code Generation**
     Teknik otomatisasi pembuatan kode sumber dari spesifikasi atau template (mis. OpenAPI → stub server, database schema → ORM class), mengurangi duplikasi dan kesalahan manual.

574. **Makefile**
     File skrip untuk GNU Make yang mendefinisikan target (_rules_), dependensi, dan perintah shell untuk build otomatis, testing, pembersihan artefak, dan dokumentasi.

575. **Task Runner**
     Alat otomatisasi pada JavaScript dan ekosistem web (mis. Gulp, Grunt, npm scripts) untuk menjalankan tugas seperti minifikasi, kompilasi Sass/Less, linting, dan unit testing secara terjadwal.

576. **Shell Scripting**
     Penulisan skrip menggunakan shell (Bash, PowerShell, Zsh) untuk mengotomasi tugas sistem—manajemen file, pipeline teks, eksekusi batch—dengan sintaks dan utilitas built-in.

577. **Batch File**
     Skrip teks di Windows (`.bat` atau `.cmd`) yang berisi perintah DOS/PowerShell berurutan, digunakan untuk automatisasi tugas administrasi dan deployment.

578. **Shebang**
     Baris pertama dalam skrip Unix-like yang diawali `#!` dan menunjuk interpreter (mis. `#!/usr/bin/env python3`), memungkinkan skrip dieksekusi langsung sebagai program.

579. **Stack Trace**
     Daftar panggilan fungsi (call stack) yang terekam saat terjadi error atau exception, menunjukkan urutan dan lokasi kode yang dieksekusi hingga titik kegagalan.

580. **Core Dump**
     Snapshot isi memori proses yang ditulis ke disk saat program crash atau menerima sinyal tertentu, berguna untuk analisis post-mortem dengan debugger.

581. **Minidump**
     File ringkas berisi subset data memori dan informasi thread saat crash, memudahkan pengumpulan laporan kegagalan di aplikasi production tanpa ukuran file terlalu besar.

582. **Debug Symbols**
     Informasi tambahan (nama variabel, jalur sumber, offset fungsi) yang disertakan dalam biner saat build debug, memungkinkan debugger menampilkan konteks asli kode sumber.

583. **Symbol Table**
     Struktur data dalam biner atau executable yang mencatat alamat fungsi, variabel, dan label, digunakan oleh linker dan debugger untuk resolusi simbol.

584. **Crash Report**
     Dokumen atau paket data yang mencakup stack trace, core/minidump, metadata environment, dan log runtime untuk rekonstuksi kondisi saat kegagalan, sering dikirim otomatis oleh aplikasi.

585. **Release Artifact**
     Paket teruji dan versi-stable dari aplikasi atau library (biner, JAR, wheel, Docker image, dokumentasi), ditandai dengan versi semantik dan didistribusikan melalui registry atau repositori.

586. **Application Binary Interface (ABI)**
     Spesifikasi low-level yang menentukan bagaimana program berinteraksi dengan sistem operasi dan runtime pada level biner—meliputi konvensi pemanggilan fungsi, tata letak memori struktur, dan registri yang digunakan—sehingga modul yang dikompilasi terpisah dapat saling bekerja tanpa source code.

587. **Monorepo vs Polyrepo**
     \- _Monorepo_: satu repositori tunggal menyimpan kode untuk banyak proyek atau layanan, memudahkan koordinasi versi dan refaktor lintas-paket.
     \- _Polyrepo_: setiap proyek atau layanan memiliki repositori terpisah, menyederhanakan manajemen akses dan pipeline CI/CD per-proyek tetapi memperumit sinkronisasi perubahan lintas-proyek.

588. **Vendor Lock-In**
     Situasi di mana aplikasi atau infrastruktur menjadi sangat tergantung pada teknologi atau layanan penyedia tertentu sehingga sulit atau mahal bermigrasi ke alternatif lain tanpa perubahan signifikan pada arsitektur atau kode.

589. **Lockfile**
     Berkas (mis. `package-lock.json`, `yarn.lock`, `Pipfile.lock`) yang mencatat versi pasti dari setiap dependensi dan sub-dependensi suatu proyek, menjamin reproduksibilitas build lintas mesin dan waktu.

590. **Dockerfile**
     Skrip deklaratif yang dituliskan dalam format khusus untuk Docker, mendefinisikan langkah-langkah (base image, instalasi paket, salin file, perintah startup) guna membangun image kontainer aplikasi.

591. **Docker Compose File**
     Konfigurasi YAML (`docker-compose.yml`) yang mendefinisikan layanan, jaringan, dan volume untuk menjalankan multi-kontainer Docker sebagai satu aplikasi terpadu dengan perintah `docker-compose up`.

592. **Helm Chart**
     Paket konfigurasi untuk Kubernetes yang mengemas kumpulan _templates_ YAML (Deployment, Service, ConfigMap) beserta nilai variabel (`values.yaml`), memudahkan instalasi, upgrade, dan rollback aplikasi di cluster.

593. **OCI (Open Container Initiative)**
     Organisasi standar terbuka yang merumuskan spesifikasi format image wujud (`OCI Image Format`) dan runtime (`OCI Runtime Specification`) untuk menjamin interoperabilitas ekosistem kontainer.

594. **Image Registry**
     Layanan penyimpanan dan distribusi image kontainer (Docker Registry, GitHub Container Registry, Amazon ECR) yang memungkinkan pull/push image oleh developer dan pipeline otomatis.

595. **Option Parser**
     Komponen library (mis. `getopt`, `argparse`, `cobra`) yang mempermudah definisi, parsing, dan validasi flag atau argumen baris perintah aplikasi CLI, serta menyajikan pesan bantuan (help).

596. **Command-Line Flag**
     Parameter yang diawali satu atau dua dash (`-v`, `--verbose`) untuk mengubah perilaku program saat dieksekusi di CLI, sering digunakan untuk mode debug, konfigurasi file, atau level log.

597. **Continuous Localization**
     Integrasi otomatis proses penerjemahan dan validasi string aplikasi ke dalam pipeline CI/CD, memonitor perubahan teks sumber dan mendorong update ke layanan penerjemah atau repositori i18n.

598. **Content Management System (CMS)**
     Aplikasi server-side yang menyediakan antarmuka admin untuk membuat, mengedit, dan mempublikasikan konten web—sering memiliki plugin, tema, dan API untuk ekstensi (mis. WordPress, Drupal).

599. **Editorial Workflow**
     Tahapan terstruktur dalam produksi konten (drafting, review, approval, publishing), sering diotomasi lewat tool (mis. CMS, static site generator) dengan status dan notifikasi untuk kolaborasi tim.

600. **Voice and Tone**
     Pedoman penulisan yang mendefinisikan karakter suara (voice) merek atau dokumentasi—misalnya “informal tetapi profesional”—dan variasi nada (tone) sesuai konteks audiens, seperti teknis vs ringkas.

601. **Readability Score**
     Penilaian numerik (mis. Flesch–Kincaid, SMOG) yang mengukur seberapa mudah teks dipahami berdasarkan panjang kalimat, kompleksitas kata, dan struktur, membantu penyusunan dokumentasi yang lebih jelas.

602. **Localization Pipeline**
     Rangkaian tool dan proses—ekstraksi string, penerjemahan, validasi, integrasi kembali—yang menjamin aplikasi mendukung multi-bahasa dengan kualitas dan konsistensi tinggi.

603. **Syntax vs. Semantics**
     \- _Syntax_: aturan tata letak dan struktur kode (grammar) yang harus diikuti agar program valid menurut compiler atau interpreter.
     \- _Semantics_: arti atau efek eksekusi kode yang mematuhi syntax, termasuk perilaku runtime dan perubahan state.

604. **Transclusion**
     Teknik menyertakan konten dari satu dokumen ke dokumen lain pada saat rendering (mis. `{% include %}` di templating engine), mempromosikan reuse dan konsistensi teks.

605. **Include Guard**
     Mekanisme di pra-prosesor C/C++ (`#ifndef … #define … #endif`) untuk mencegah multiple inclusion header file, menghindari error definisi ganda dan konflik dependensi.

606. **Literate Programming**
     Pendekatan menulis program di mana kode dan dokumentasi dipadukan dalam satu berkas—penulis menulis narasi konseptual yang mengalir, diselingi potongan kode yang diekstrak dan dieksekusi oleh sistem (mis. WEB oleh Donald Knuth).

607. **Currying**
     Teknik dalam pemrograman fungsional untuk mengubah fungsi berparameter banyak menjadi rangkaian fungsi berparameter tunggal, memungkinkan pengaplikasian bertahap (partial application).

608. **Partial Application**
     Proses membuat fungsi baru dengan mengikat (pre-fill) sebagian argumen fungsi asli, menghasilkan fungsi yang menunggu sisa argumen.

609. **Higher-Order Function**
     Fungsi yang mengambil fungsi lain sebagai argumen dan/or mengembalikan fungsi, memfasilitasi pola seperti _map_, _filter_, dan komposisi fungsional.

610. **Thunk**
     Fungsi tanpa parameter yang membungkus ekspresi atau komputasi untuk dieksekusi nanti, sering dipakai untuk menunda evaluasi atau mengimplementasikan kontrol alur khusus.

611. **Generator**
     Fungsi atau metode yang dapat menahan status eksekusi dan mengembalikan nilai berurutan tiap kali dipanggil ulang (via `yield`), berguna untuk menangani koleksi besar atau aliran data.

612. **Async Iterator**
     Objek yang memenuhi protokol iterator asinkron—menyediakan metode `next()` yang mengembalikan _Promise_ berisi `{ value, done }`—memungkinkan iterasi atas sumber data asinkron (mis. streaming I/O).

613. **Active Record Pattern**
     Pola _ORM_ di mana setiap kelas domain merepresentasikan tabel basis data dan bertanggung jawab langsung atas CRUD (Create, Read, Update, Delete) data-nya sendiri, menggabungkan logika bisnis dan akses data.

614. **Data Mapper Pattern**
     Pola _ORM_ di mana objek domain sepenuhnya terpisah dari detail penyimpanan; komponen _mapper_ bertugas menerjemahkan antara objek dan basis data, memisahkan tanggung jawab lapisan domain dan eskalasi data.

615. **Repository Pattern**
     Abstraksi lapisan penyimpanan data yang menyediakan antarmuka koleksi berorientasi domain untuk menyimpan dan mengambil objek, menyembunyikan detail query atau akses _persistence_.

616. **Unit of Work**
     Pola yang melacak objek-objek yang diubah selama suatu transaksi bisnis dan menulis semua perubahan ke storage dalam satu batch atomik, menjaga konsistensi _persistence_.

617. **Flyweight Pattern**
     Pola struktural untuk mengurangi penggunaan memori dengan berbagi objek yang bersifat tak berubah (immutable) di antara banyak konteks, memisahkan _intrinsic_ dari _extrinsic_ state.

618. **State Pattern**
     Pola perilaku di mana objek mengubah perilaku internalnya ketika state-nya berubah, seakan-akan mengganti kelasnya, memudahkan implementasi _finite state machine_ dalam kode berorientasi objek.

619. **Composite Pattern**
     Pola struktural yang mengizinkan komposisi objek dalam struktur pohon untuk merepresentasikan hierarki bagian–keseluruhan, sehingga klien dapat memperlakukan objek tunggal dan komposit secara uniform.

620. **Chain of Responsibility Pattern**
     Pola perilaku di mana rangkaian objek handler terhubung—setiap handler dapat memproses permintaan atau meneruskannya ke handler berikut—meminimalkan ketergantungan pengirim dan penerima permintaan.

621. **Mediator Pattern**
     Pola perilaku yang mendefinisikan objek mediator pusat untuk mengelola interaksi antar objek-komponen, mengurangi koneksi langsung (_coupling_) dan memfasilitasi perubahan komunikasi.

622. **Interpreter Pattern**
     Pola perilaku untuk mendefinisikan _grammar_ dan interpretasi elemen bahasa kecil melalui objek–objek yang mewakili aturan grammar, memungkinkan evaluasi ekspresi yang di-parsing.

623. **NP-Complete vs NP-Hard**
     Kelas masalah komputasi dalam teori kompleksitas:
     \- _NP-Complete_: masalah dalam NP yang setiap masalah NP lain dapat ­diredusir dengannya dalam waktu polinomial.
     \- _NP-Hard_: masalah yang sekurang-kurangnya se-sulit NP-Complete, tetapi tidak harus berada di NP (solusinya mungkin tidak dapat diverifikasi dalam waktu polinomial).

624. **Semantic Versioning Range**
     Notasi penentu kumpulan versi paket berdasarkan aturan semantik (mis. `^1.2.3`, `~2.4.0`), memudahkan manajer paket memilih rentang versi kompatibel secara otomatis.

625. **Literate Configuration**
     Praktik menulis file _infrastructure as code_ atau konfigurasi (Terraform, Ansible) dengan dokumentasi naratif terintegrasi, menjelaskan tujuan dan konteks setiap blok pengaturan.

626. **OpenTelemetry**
     Standar terbuka untuk mengumpulkan, menghasilkan, dan mengekspor data telemetri (traces, metrics, logs) dari aplikasi dan infrastruktur guna observability lintas platform dan vendor.

627. **Interface Definition Language (IDL)**
     Bahasa deklaratif untuk mendefinisikan dan menggambarkan antarmuka layanan RPC atau mikroservis, memisahkan kontrak API dari implementasi (mis. Thrift IDL, Protocol Buffers `.proto`).

628. **TLS Termination**
     Titik di arsitektur jaringan atau load balancer tempat koneksi TLS/SSL diakhiri (didekripsi), sehingga trafik antara terminator dan aplikasi dapat dilakukan dalam HTTP biasa.

629. **Apache Maven**
     Alat automasi build dan manajemen dependensi berbasis XML untuk proyek Java, menggunakan siklus hidup terdefinisi (compile, test, package) dan repositori terpusat.

630. **Gradle**
     Sistem build modern untuk JVM dan bahasa lain, menggunakan DSL Groovy atau Kotlin, mendukung eksekusi paralel, build cache, dan manajemen dependensi berbasis Maven/Ivy.

631. **Apache Ant**
     Alat build awal Java berbasis skrip XML yang mengeksekusi target dan tugas (compile, jar, copy), dengan fleksibilitas tinggi namun tanpa manajemen dependensi bawaan.

632. **CMake**
     Sistem build agnostik-platform yang menghasilkan file proyek atau skrip build (Makefile, Ninja, Visual Studio) dari skrip konfigurasi `CMakeLists.txt`, memudahkan portable compilation C/C++.

633. **Continuous Profiling**
     Praktik pemantauan performa aplikasi secara berkelanjutan di lingkungan produksi, mengumpulkan data CPU, memori, I/O untuk mendeteksi _hot spots_ dan regresi performa seiring waktu.

634. **Dynamic Instrumentation**
     Teknik menambahkan probes atau hooks ke aplikasi yang sedang berjalan (runtime) tanpa perlu recompile, memfasilitasi tracing, profiling, dan debugging di lapangan (mis. eBPF, DTrace).

635. **Distributed Tracing**
     Metode observability yang menandai dan melacak alur eksekusi permintaan melintasi layanan terdistribusi, mengumpulkan span dan trace untuk memetakan latensi dan dependensi antar layanan.

636. **OpenTracing**
     API vendor-agnostik untuk distributed tracing yang memungkinkan aplikasi menghasilkan span dan trace secara konsisten, kemudian di-_back-end_ oleh sistem seperti Jaeger atau Zipkin.

637. **Istio**
     Implementasi service mesh open source untuk Kubernetes yang menyediakan kontrol lalu lintas, kebijakan keamanan, dan observability secara transparan melalui _sidecar proxy_ (Envoy).

638. **Linkerd**
     Ringan service mesh untuk Kubernetes dan _cloud-native_ yang memfokuskan pada kesederhanaan, keamanan, dan kinerja, dengan proxy _microservlet_ terintegrasi.

639. **Envoy Proxy**
     Proxy _edge_ dan _sidecar_ high-performance open source yang mendukung HTTP/2, gRPC, dan observability kaya, sering menjadi dasar bagi service mesh seperti Istio dan Consul.

640. **gRPC IDL (Protocol Buffers)**
     Kombinasi RPC framework dan Interface Definition Language milik Google yang menggunakan `.proto` untuk mendefinisikan layanan dan message, dengan kode klien/servis ter-generate otomatis.

641. **WireGuard**
     Protokol dan implementasi VPN modern yang sederhana, cepat, dan aman, menggunakan kriptografi mutakhir dan mudah dikonfigurasi dibandingkan IPsec atau OpenVPN.

642. **Nordic REST**
     Pendekatan desain API REST yang menekankan ketebalan hypermedia: setiap respons menyertakan link dan aksi (`menu-driven`), memperkuat prinsip HATEOAS di RESTful design.

643. **JSON Web Encryption (JWE)**
     Standar berbasis JSON untuk mengenkripsi konten pesan secara end-to-end, melengkapi JWS (JSON Web Signature) dalam keluarga JWT dengan lapisan kerahasiaan.

644. **PEM vs DER Encoding**
     Dua format penyimpanan sertifikat dan kunci kriptografi:
     \- _DER_: encoding biner ASN.1.
     \- _PEM_: DER base64-encoded dengan header/footer teks (`-----BEGIN CERTIFICATE-----`).

645. **Policy as Data**
     Pendekatan _policy-as-code_ yang menyimpan kebijakan (akses, keamanan, konfigurasi) dalam format data (JSON/YAML) dan dievaluasi oleh mesin policy (mis. OPA) secara terpisah dari aplikasi.

646. **Mutual TLS (mTLS)**
     Varian TLS di mana kedua pihak (klien dan server) saling memverifikasi sertifikat digital saat handshake, menyediakan otentikasi dua-arah dan meningkatkan keamanan komunikasi.

647. **Zero Trust Network Access (ZTNA)**
     Model keamanan yang mengontrol akses ke aplikasi dan data berdasarkan kebijakan granular, memverifikasi setiap permintaan tanpa mengandalkan perimeter jaringan tradisional.

648. **Rubber Duck Debugging**
     Teknik memecahkan masalah di mana pengembang menjelaskan kode dan logika secara detail kepada objek tidak hidup (mis. mainan bebek), membantu menemukan kesalahan melalui penjelasan eksplisit.

649. **Minimal Reproducible Example (MRE)**
     Contoh kode paling singkat dan lengkap yang dapat menimbulkan masalah yang sama, digunakan untuk mempermudah debugging bersama atau laporan bug di issue tracker.

650. **Software Bill of Materials (SBOM)**
     Daftar terstruktur semua komponen, pustaka, dan dependensi dalam sebuah perangkat lunak, termasuk versi, lisensi, dan sumber, untuk audit keamanan dan kepatuhan.

651. **GitHub Actions**
     Platform CI/CD terintegrasi di GitHub yang menjalankan workflow otomatis berdasarkan event repositori (push, pull request), menggunakan file definisi YAML di `.github/workflows/`.

652. **Jenkins Pipeline**
     Kerangka kerja di Jenkins untuk mendefinisikan proses build, test, dan deploy sebagai kode (Jenkinsfile), mendukung pipeline terstruktur dengan tahap (stage) dan langkah (step).

653. **Artifact Repository**
     Layanan penyimpanan dan distribusi artefak build (biner, library, kontainer), seperti Nexus, Artifactory, atau GitHub Packages, yang mengelola versi, metadata, dan izin akses.

654. **Immutable Infrastructure Pattern**
     Praktik menerapkan perubahan dengan mengganti seluruh unit (VM, kontainer) daripada memodifikasi yang sudah berjalan, memastikan konsistensi dan memudahkan rollback.

655. **Dynamic Configuration**
     Teknik memuat dan menerapkan parameter konfigurasi secara runtime tanpa restart aplikasi, memungkinkan perubahan cepat pada perilaku sistem melalui layanan konfigurasi terpusat (mis. Consul, Spring Cloud Config).

656. **Smart Contract**
     Program terdesentralisasi yang disimpan dan dijalankan di blockchain, secara otomatis mengeksekusi logika transaksi ketika kondisi tertentu terpenuhi, tanpa perantara.

657. **Nonce (Blockchain)**
     Angka sekali pakai yang dimasukkan dalam header blok atau transaksi untuk menghasilkan hash unik dan mencegah replay attack; di Proof-of-Work, miner mengubah nonce hingga menemukan hash yang memenuhi target.

658. **Proof of Work (PoW)**
     Mekanisme konsensus di blockchain di mana node (miner) bersaing untuk memecahkan teka-teki kriptografis—menemukan hash dengan nilai di bawah target—sebagai bukti kerja komputasi sebelum blok baru diterima.

659. **Proof of Stake (PoS)**
     Mekanisme konsensus alternatif di mana hak menambang atau memvalidasi blok ditentukan oleh jumlah token yang “dipertaruhkan” (staked), mengurangi konsumsi energi dibanding PoW.

660. **Gas (Ethereum)**
     Unit ukur biaya komputasi di jaringan Ethereum; setiap operasi EVM (Ethereum Virtual Machine) membutuhkan sejumlah gas tertentu, dibayar oleh pengirim transaksi untuk mencegah penyalahgunaan sumber daya.

661. **Sharding (Blockchain)**
     Teknik skalabilitas horizontal pada database terdistribusi atau blockchain di mana jaringan dibagi menjadi beberapa fragmen (“shard”) yang memproses transaksi dan kontrak secara paralel untuk meningkatkan throughput.

662. **Layer 2 Scaling**
     Solusi penskalaan yang berjalan di atas blockchain utama (Layer 1), seperti rollups atau state channels, memproses transaksi off-chain dan menyelesaikan ringkasannya di mainnet untuk mengurangi beban dan biaya.

663. **Oracle (Blockchain)**
     Layanan tepercaya yang menyediakan data eksternal (harga aset, kondisi cuaca) ke smart contract, menjembatani dunia nyata dan blockchain melalui mekanisme verifikasi on-chain.

664. **Token Economy**
     Desain insentif dan aturan ekonomi dalam ekosistem blockchain menggunakan token—termasuk distribusi, mekanisme burning/minting, dan tata kelola—untuk memotivasi partisipasi dan menjaga stabilitas.

665. **Genesis Block**
     Blok pertama dalam sebuah blockchain, sering kali berisi parameter konfigurasi awal jaringan dan tidak memiliki referensi ke blok sebelumnya.

666. **Overfitting**
     Kondisi di mana model pembelajaran mesin terlalu “menghafal” data pelatihan, menurunkan kemampuannya menggeneralisasi pada data baru; diatasi dengan lebih banyak data atau teknik regularisasi.

667. **Underfitting**
     Situasi di mana model pembelajaran mesin terlalu sederhana untuk menangkap pola dalam data pelatihan, menghasilkan performa buruk baik pada data pelatihan maupun pengujian.

668. **Cross-Validation**
     Teknik evaluasi model dengan membagi data menjadi beberapa lipatan (fold), melatih pada subset dan menguji pada sisanya secara bergantian, guna mendapatkan estimasi performa yang lebih andal.

669. **Regularization**
     Metode menambahkan penalti pada fungsi kerugian (loss) untuk membatasi kompleksitas model—misalnya L1 (lasso) atau L2 (ridge)—mengurangi risiko overfitting.

670. **Gradient Descent**
     Algoritma optimasi iteratif untuk meminimalkan fungsi kerugian dengan memperbarui parameter model ke arah negatif gradien secara proporsional terhadap learning rate.

671. **Learning Rate**
     Hyperparameter yang menentukan besar langkah pembaruan parameter dalam algoritma optimasi; nilai terlalu besar menyebabkan divergensi, terlalu kecil memperlambat konvergensi.

672. **Epoch**
     Satu putaran penuh melalui seluruh dataset pelatihan dalam proses optimasi; sering diulang beberapa kali agar model menyempurnakan bobotnya.

673. **Batch Size**
     Jumlah sampel yang digunakan untuk menghitung gradien sekaligus dalam satu iterasi pembaruan parameter; batch kecil meningkatkan variasi pembaruan, batch besar stabil tetapi memerlukan memori lebih besar.

674. **Loss Function**
     Fungsi matematika yang mengukur perbedaan antara prediksi model dan nilai sebenarnya, menjadi dasar untuk optimasi; contoh: Mean Squared Error, Cross-Entropy.

675. **Activation Function**
     Fungsi non-linear yang diterapkan pada output neuron dalam jaringan saraf, memungkinkan model mempelajari representasi kompleks; contoh: ReLU, Sigmoid, Tanh.

676. **Weight Initialization**
     Proses pemberian nilai awal bobot pada jaringan saraf sebelum pelatihan; metode populer termasuk _Xavier/Glorot_ dan _He initialization_ untuk menjaga varians sinyal tetap stabil antar lapisan.

677. **Batch Normalization**
     Teknik normalisasi input setiap lapisan selama pelatihan neural network dengan menghitung mean dan variance per mini-batch, mempercepat konvergensi dan menstabilkan pelatihan.

678. **Dropout**
     Metode regularisasi neural network di mana sejumlah neuron dipilih acak untuk “dimatikan” (output = 0) pada setiap iterasi pelatihan, mengurangi overfitting dengan memaksa redundansi fitur.

679. **Early Stopping**
     Strategi menghentikan pelatihan model ketika performa pada _validation set_ mulai menurun, mencegah overfitting dengan tidak melatih terlalu lama.

680. **Hyperparameter Tuning**
     Proses mencari nilai hyperparameter optimal (learning rate, batch size, arsitektur) melalui teknik seperti _grid search_, _random search_, atau _Bayesian optimization_.

681. **Transfer Learning**
     Pendekatan pembelajaran mesin di mana model pra-terlatih pada tugas besar (misalnya ImageNet) diadaptasi (fine-tuned) untuk tugas serupa dengan dataset lebih kecil, mempercepat pelatihan dan meningkatkan performa.

682. **Fine-Tuning**
     Tahap pelatihan lanjutan di mana sebagian atau seluruh bobot model pra-terlatih diperbarui pada dataset target dengan learning rate lebih kecil, menyesuaikan representasi fitur.

683. **Ensemble Methods**
     Teknik penggabungan beberapa model (bagging, boosting, stacking) untuk memperoleh prediksi agregat yang biasanya lebih akurat dan lebih stabil daripada model tunggal.

684. **Bagging (Bootstrap Aggregating)**
     Ensemble method yang melatih beberapa model pada _bootstrapped_ subsample data pelatihan, lalu mengagregasi prediksi (rata-rata atau voting) untuk mengurangi varians.

685. **Boosting**
     Metode ensemble di mana model dibangun berurutan—setiap model berikutnya memfokuskan on kesalahan model sebelumnya—contoh: AdaBoost, Gradient Boosting Machines.

686. **Stacking**
     Teknik ensemble di mana output beberapa model dasar (level–0) digunakan sebagai input ke model tingkat kedua (meta–learner) untuk menghasilkan prediksi akhir.

687. **ROC Curve & AUC**
     _Receiver Operating Characteristic (ROC)_ adalah kurva yang memplot _True Positive Rate_ vs. _False Positive Rate_ untuk berbagai threshold; _Area Under Curve (AUC)_ mengukur kinerja klasifikasi secara keseluruhan.

688. **Precision, Recall, F1-Score**
     Metrik evaluasi model klasifikasi:
     \- _Precision_: proporsi prediksi positif yang benar.
     \- _Recall_: proporsi kasus positif yang terdeteksi.
     \- _F1-Score_: harmonik rata-rata precision dan recall.

689. **Confusion Matrix**
     Tabel 2×2 (atau NxN) yang menampilkan jumlah _True Positive_, _True Negative_, _False Positive_, dan _False Negative_ untuk evaluasi model klasifikasi.

690. **Gradient Checking**
     Teknik verifikasi implementasi backpropagation dengan membandingkan gradien analitik dengan gradien numerik melalui pendekatan _finite differences_.

691. **Data Augmentation**
     Strategi memperluas dataset pelatihan dengan membuat sampel sintetis melalui transformasi (rotasi, skala, flip pada gambar; sinonim replacement pada teks), meningkatkan ketahanan model.

692. **Word Embedding**
     Representasi kata sebagai vektor kontinu berdimensi rendah (Word2Vec, GloVe, FastText) yang memetakan makna semantik ke jarak geometrik.

693. **Sequence-to-Sequence (Seq2Seq)**
     Arsitektur model (biasanya RNN atau Transformer) yang memetakan satu urutan (input) ke urutan lain (output), digunakan pada terjemahan mesin dan _chatbot_.

694. **Attention Mechanism**
     Komponen dalam model Seq2Seq yang memberi bobot pada bagian input yang relevan saat menghasilkan setiap token output, meningkatkan performa pada urutan panjang.

695. **Transformer Architecture**
     Model berbasis _self-attention_ tanpa RNN/CNN, terdiri dari encoder–decoder stack (multi-head attention, feed-forward), menjadi tulang punggung BERT, GPT, dan varian besar bahasa.

696. **Layer Normalization**
     Teknik normalisasi input pada setiap lapisan dalam jaringan saraf (neural network) dengan menghitung mean dan variance sepanjang fitur (bukan batch), sering digunakan pada model Transformer untuk stabilisasi pelatihan.

697. **Residual Connection (Skip Connection)**
     Jalur pintas dalam arsitektur jaringan saraf yang menambahkan input suatu lapisan langsung ke output lapisan berikutnya, memudahkan aliran gradien dan memungkinkan pelatihan model yang sangat dalam.

698. **Positional Encoding**
     Metode menambahkan informasi urutan (posisi) ke embedding token dalam model berbasis self-attention (Transformer), biasanya melalui fungsi sinusoidal atau embedding yang dapat dipelajari.

699. **Self-Supervised Learning**
     Paradigma pembelajaran mesin di mana model belajar representasi dari data tanpa label eksplisit dengan memformulasikan tugas proxy (pretext task), seperti memprediksi bagian data yang disembunyikan.

700. **Reinforcement Learning (RL)**
     Metode pembelajaran di mana agen belajar memilih aksi dalam suatu lingkungan berdasarkan imbalan (reward) untuk memaksimalkan akumulasi reward jangka panjang, dipakai dalam game dan robotika.

701. **Markov Decision Process (MDP)**
     Kerangka matematis formal dalam RL yang memodelkan lingkungan sebagai tuple (states, actions, transition probabilities, rewards, discount factor), memandu algoritma RL.

702. **Q-Learning**
     Algoritma RL berbasis nilai (value-based) yang mempelajari fungsi Q(state, action) dengan memperbarui estimasi nilai tindakan menggunakan _temporal-difference_.

703. **Policy Gradient Methods**
     Kelas algoritma RL yang secara langsung mempelajari parameter kebijakan (policy) probabilistik dengan memaksimalkan ekspektasi return menggunakan gradien.

704. **Actor-Critic Architecture**
     Gabungan pendekatan nilai dan kebijakan dalam RL: _actor_ memilih aksi berdasarkan kebijakan, sedangkan _critic_ mengevaluasi aksi dengan fungsi nilai untuk membimbing pembaruan.

705. **Generative Adversarial Network (GAN)**
     Arsitektur neural network yang terdiri dari dua jaringan—_generator_ dan _discriminator_—yang dilatih secara bersaing agar generator mampu menghasilkan data sintetis menyerupai data nyata.

706. **Variational Autoencoder (VAE)**
     Model generatif probabilistik yang mempelajari distribusi laten data dengan mengkodekan input ke distribusi probabilitas dan mendekode sampel dari distribusi tersebut ke rekonstruksi.

707. **Glossary**
     Bagian dokumentasi yang menyajikan definisi istilah dan akronim khusus domain secara alfabetis, membantu pembaca memahami terminologi teknis.

708. **Style Guide**
     Dokumen yang menetapkan aturan penulisan (bahasa, terminologi, format, contoh kode) untuk dokumentasi, API, dan kode sumber agar konsisten di seluruh proyek.

709. **API Reference**
     Dokumentasi terperinci tentang antarmuka pemrograman—daftar fungsi, metode, parameter, respons, dan contoh penggunaan—yang digunakan pengembang untuk integrasi.

710. **Cookbook**
     Koleksi resep kode atau pola solusi singkat untuk masalah umum dalam suatu bahasa atau framework, memberikan contoh langsung (“code snippets”) dan penjelasan minimal.

711. **Space Complexity**
     Ukuran memori tambahan yang dibutuhkan algoritma relatif terhadap ukuran input _n_, dinyatakan dengan notasi Big O (mis. _O(n)_, _O(log n)_).

712. **Recursion vs. Iteration**
     \- _Recursion_: fungsi memanggil dirinya sendiri untuk memecah masalah menjadi sub-masalah.
     \- _Iteration_: penggunaan struktur kontrol berulang (_for_, _while_) untuk mengulangi eksekusi blok kode.

713. **Inline Documentation**
     Penjelasan singkat yang disisipkan langsung di dalam kode (komentar baris atau blok) untuk menerangkan maksud atau kompleksitas suatu potongan kode bagi pembaca.

714. **Clone (Git)**
     Operasi `git clone` untuk menyalin seluruh repositori remote beserta riwayat commit-nya ke direktori lokal, memungkinkan pengembang memiliki salinan penuh proyek.

715. **Upstream / Downstream**
     \- _Upstream_: repositori atau branch sumber yang menjadi acuan bagi kolaborator.
     \- _Downstream_: fork atau clone yang menarik perubahan dari upstream ke dalam salinan lokal.

716. **Git Submodule**
     Mekanisme memasukkan satu repositori Git di dalam repositori lain sebagai dependensi versi-terdefinisi, menjaga isolasi riwayat dan sinkronisasi manual.

717. **Code Playground**
     Lingkungan interaktif online (mis. CodeSandbox, JSFiddle, DartPad) untuk mencoba potongan kode, bereksperimen dengan library, dan berbagi contoh secara instan tanpa setup lokal.

718. **Live Coding**
     Teknik presentasi atau pembelajaran di mana pengembang menulis kode secara real-time, memperlihatkan proses berpikir, debugging, dan penerapan solusi di depan audiens.

719. **Scratchpad**
     Area kerja sementara—baik dalam editor, REPL, atau notebook—untuk mengetes ide, menulis snippet kecil, atau melakukan eksperimen sebelum memasukkannya ke basis kode utama.

720. **Documentation-First Development**
     Pendekatan di mana kontrak API, antarmuka, atau interaksi modul ditulis dan disetujui terlebih dahulu (specification, OpenAPI), kemudian implementasi dikembangkan untuk memenuhi dokumen tersebut.

721. **Proselint (Prose Linting)**
     Alat otomatis untuk memeriksa gaya penulisan teknis (_prose_)—mengidentifikasi kalimat pasif, jargon berlebih, atau inkonsistensi istilah—guna meningkatkan kejelasan dokumentasi.

722. **Spell Checker**
     Fitur dalam editor atau pipeline dokumentasi yang memeriksa kesalahan ejaan dan istilah teknis, mencegah typo dan memastikan konsistensi terminologi di seluruh materi.

723. **Typo Tolerance**
     Strategi atau library (mis. fuzzy search, autocorrect) dalam antarmuka dan API CLI yang mengoreksi atau menyarankan perintah/parameter saat pengguna melakukan kesalahan ketik.

724. **Git Fetch vs. Git Pull**
     \- `git fetch`: mengambil update dari remote tanpa menerapkannya ke branch lokal—menyegarkan _refs_ remote.
     \- `git pull`: setara `git fetch` kemudian `git merge`, langsung mengintegrasikan perubahan ke branch aktif.

725. **Git Stash**
     Mekanisme di Git untuk menyimpan sementara perubahan teracak (working directory dan index) ke dalam tumpukan (stack), sehingga Anda dapat berpindah branch tanpa commit, lalu menerapkannya kembali dengan `git stash pop` atau `git stash apply`.

726. **Git Tag**
     Penanda pada commit tertentu yang sering digunakan untuk menandai rilis; dapat berupa:
     \- _Lightweight Tag_: referensi lokus sederhana ke commit.
     \- _Annotated Tag_: objek Git yang berisi metadata (penanda, pesan, tanda tangan GPG) dan lebih disarankan untuk rilis resmi.

727. **Git Worktree**
     Fitur Git yang memungkinkan checkout beberapa working directory terpisah (worktrees) dari satu repositori yang sama, memudahkan bekerja di berbagai branch secara paralel tanpa clone baru.

728. **Git Revert**
     Perintah untuk membatalkan perubahan yang dilakukan oleh commit tertentu dengan membuat commit baru yang menginverse patch, sehingga riwayat tetap utuh dan dapat ditelusuri.

729. **Interactive Rebase**
     Mode rebase Git (`git rebase -i`) yang memungkinkan Anda memilih, menyusun ulang, mengedit, menggabung (squash), atau mengubah pesan banyak commit dalam satu operasi interaktif sebelum mengintegrasikannya kembali.

730. **Squash Commit**
     Teknik menggabungkan beberapa commit menjadi satu commit ringkas yang lebih bermakna—tidak hanya membersihkan riwayat, tetapi juga memudahkan review dan rollback.

731. **Code of Conduct**
     Dokumen yang menetapkan standar perilaku, etika, dan inklusivitas untuk kontributor dan komunitas proyek open source atau tim pengembang, membantu menjaga lingkungan kolaboratif yang positif.

732. **Contributor License Agreement (CLA)**
     Perjanjian hukum yang harus ditandatangani oleh kontributor agar proyek memiliki hak jelas atas kontribusi kode, melindungi hak cipta dan memudahkan penerbitan di bawah lisensi proyek.

733. **License Badge**
     Lencana kecil (shields.io atau serupa) yang ditempatkan di bagian atas README untuk menampilkan jenis lisensi proyek secara visual, memudahkan pembaca mengenali hak penggunaan dan distribusi.

734. **Coding Standard**
     Kumpulan pedoman dan aturan penulisan kode (indentasi, penamaan, struktur file) yang disepakati tim untuk memastikan konsistensi, keterbacaan, dan kemudahan perawatan kode.

735. **Cyclic Dependency**
     Situasi di mana modul atau paket saling membutuhkan satu sama lain secara melingkar, mengakibatkan kesulitan dalam build, testing, dan pemisahan tanggung jawab; sebaiknya dihindari atau di-break dengan refaktor.

736. **Race Detector**
     Alat otomatis (mis. Go race detector, ThreadSanitizer) untuk mendeteksi kondisi balapan pada program berkonkurensi, berguna untuk menemukan dan memperbaiki ketidaksinkronan memori sebelum produksi.

737. **Address Sanitizer (ASan)**
     Alat runtime dari compiler (Clang/GCC) yang mendeteksi kesalahan memori seperti buffer overflow, use-after-free, dan memory leak melalui instrumentasi kode otomatis.

738. **Thread Sanitizer (TSan)**
     Alat dinamis untuk mendeteksi race condition dan penggunaan variabel bersama tanpa sinkronisasi memadai, membantu developer menemukan bug sulit pada kode multithread.

739. **Coverage Report**
     Laporan yang menunjukkan persentase baris, fungsi, atau branch kode yang diuji oleh suite pengujian, dihasilkan oleh alat seperti JaCoCo, Istanbul, atau Coverage.py, untuk memandu peningkatan cakupan.

740. **Flame Graph**
     Visualisasi profil performa (CPU, I/O) yang menampilkan tumpukan panggilan (call stacks) sebagai bar horizontal berlapis, memudahkan identifikasi hot spots dalam aplikasi.

741. **Multistage Docker Build**
     Teknik dalam Dockerfile di mana beberapa tahap build digunakan (builder stage, runtime stage) untuk menghasilkan image final yang ringan dan hanya berisi artefak yang dibutuhkan.

742. **Virtual Environment**
     Isolasi lingkungan Python (mis. `venv`, `virtualenv`, `poetry`) yang memisahkan dependensi proyek per-folder, mencegah konflik versi dan memudahkan reproduksi instalasi.

743. **Poetry (Python)**
     Alat manajemen dependensi dan packaging untuk Python yang menggunakan file `pyproject.toml`, menyediakan penguncian versi, publishing, dan skrip build terintegrasi.

744. **README Badge**
     Lencana status otomatis (build passing, coverage, version, dependencies) yang ditempatkan di README untuk memberi tahu pembaca tentang kesehatan dan metadata proyek secara real-time.

745. **TODO/FIXME Comments**
     Komentar khusus dalam kode untuk menandai tugas yang harus diselesaikan (`TODO`) atau masalah yang perlu diperbaiki (`FIXME`), sering diintegrasikan dengan plugin IDE untuk pelacakan cepat.

746. **Linting Rules**
     Kumpulan pemeriksaan statis (lint rules) yang dijalankan oleh linter untuk menegakkan gaya, praktik terbaik, dan mendeteksi potensi bug—misalnya larangan variabel tak terpakai, penegakan konsistensi tanda kutip, atau batas panjang baris.

747. **AST Transformer**
     Komponen yang memanipulasi Abstract Syntax Tree (AST) sebelum atau selama kompilasi/interpretasi untuk menerapkan transformasi kode otomatis—misalnya menambahkan logging, mengimplementasikan macro, atau optimasi spesifik domain.

748. **Hot Module Replacement (HMR)**
     Fitur di bundler dan dev server (mis. Webpack, Vite) yang memungkinkan modul JavaScript atau CSS diperbarui di browser tanpa reload penuh, menjaga state aplikasi selama pengembangan.

749. **Source Code Management (SCM)**
     Proses dan alat untuk mengelola versi source code—termasuk branching, merging, tagging, dan audit trail—meliputi sistem seperti Git, Mercurial, dan Subversion.

750. **Commit Message Convention**
     Aturan format pesan commit yang disepakati tim (mis. Conventional Commits, Angular Commit Guidelines) untuk konsistensi dan automasi seperti pembuatan changelog atau peningkatan versi otomatis.

751. **Code Health**
     Kondisi keseluruhan basis kode diukur melalui metrik seperti kompleksitas siklomatis, kepadatan test, kepatuhan lint, dan waktu build, yang memengaruhi kemampuan tim dalam memelihara dan mengembangkan fitur baru.

752. **Semantic Highlighting**
     Fitur editor canggih yang memberikan pewarnaan kode berdasarkan makna semantik—misalnya membedakan tipe data, fungsi, variabel, atau parameter—bukan sekadar pola regex.

753. **API Deprecation Policy**
     Kebijakan formal yang menetapkan jangka waktu dukungan, pemberitahuan, dan proses usang (`deprecation`) untuk endpoint atau fitur API sebelum dihapus, agar konsumen dapat beradaptasi.

754. **Churn Rate**
     Metri yang menggambarkan seberapa sering file atau modul berubah selama periode tertentu, membantu mengidentifikasi area kode yang volatile dan berisiko.

755. **Snapshot Testing**
     Teknik pengujian di mana output UI atau fungsi serializable disimpan sebagai “snapshot” terverifikasi; perubahan tak terduga pada snapshot menandai perbedaan yang perlu ditinjau.

756. **CRUD (Create, Read, Update, Delete)**
     Empat operasi dasar pada penyimpanan data atau entitas dalam aplikasi, mewakili siklus hidup data dan sering dijadikan endpoint API atau metode pada repositori/ORM.

757. **Finite State Machine (FSM)**
     Model komputasi yang terdiri dari sekumpulan state, transisi antar state berdasarkan input, dan aksi opsional; banyak dipakai untuk mendesain parser, UI workflow, atau kontrol protokol.

758. **Singleton Pattern**
     Pola kreasi yang memastikan hanya satu instance dari suatu kelas pernah dibuat selama siklus hidup aplikasi, menyediakan titik akses global dan mencegah multiple instantiation.

759. **Factory Pattern**
     Pola kreasi yang menyediakan antarmuka untuk membuat objek tanpa mengekspos logika instansiasi secara langsung, memungkinkan subclass menentukan kelas konkret yang akan dibuat.

760. **Adapter Pattern**
     Pola struktural yang menghubungkan dua antarmuka inkompatibel dengan “membungkus” objek asli dalam kelas adapter, sehingga klien dapat menggunakan API yang berbeda tanpa mengubah kode sumber objek yang diadaptasi.

761. **Observer Pattern**
     Pola perilaku di mana objek (subject) mengelola daftar dependensi (observer) dan secara otomatis memberitahukan mereka saat state-nya berubah, memfasilitasi implementasi event listener dan data binding.

762. **Strategy Pattern**
     Pola perilaku yang mendefinisikan keluarga algoritma yang dapat dipertukarkan di runtime, membungkus masing-masing dalam kelas tersendiri, dan memisahkan logika pemilihan dari eksekusi.

763. **Iterator Pattern**
     Pola perilaku yang menyediakan antarmuka untuk mengakses elemen-elemen koleksi secara sekuensial tanpa mengekspos representasi internal koleksi.

764. **Facade Pattern**
     Pola struktural yang menyederhanakan antarmuka subsistem kompleks dengan menyediakan satu kelas tunggal (facade) yang mengorkestrasi panggilan ke berbagai komponen internal.

765. **Nightly Build**
     Versi perangkat lunak yang dibangun secara otomatis pada akhir hari kerja (atau jadwal tertentu) dari cabang pengembangan utama, sering digunakan untuk menguji stabilitas integrasi terkini sebelum rilis resmi.

766. **Regression Testing**
     Pengujian ulang terhadap fitur dan modul yang sudah ada setelah perubahan kode untuk memastikan tidak ada fungsi yang rusak atau perilaku yang berubah secara tidak diinginkan.

767. **User Acceptance Testing (UAT)**
     Tahapan pengujian di mana pengguna akhir atau pemangku kepentingan mengevaluasi aplikasi untuk memastikan memenuhi kebutuhan bisnis dan siap dirilis.

768. **Penetration Testing (Pen Test)**
     Simulasi serangan siber terhadap aplikasi atau infrastruktur oleh tim internal atau pihak ketiga untuk mengidentifikasi kerentanan yang dapat dieksploitasi.

769. **Nightly Regression Suite**
     Kumpulan pengujian otomatis (unit, integrasi, end-to-end) yang dijalankan pada build malam (nightly build) untuk mendeteksi regresi besar sebelum pengguna atau QA diberikan akses.

770. **Maintenance Window**
     Jangka waktu terjadwal di mana pemeliharaan sistem, patch keamanan, atau upgrade infrastruktur dapat dilakukan dengan toleransi downtime minimal.

771. **Rollback Plan**
     Dokumen atau prosedur terperinci untuk mengembalikan sistem ke versi atau konfigurasi sebelumnya jika rilis baru gagal atau menimbulkan masalah kritis.

772. **Release Candidate (RC) Freeze**
     Tahap dalam pengembangan di mana hanya perbaikan bug kritis yang diizinkan pada codebase RC untuk mempersiapkan rilis final tanpa menambahkan fitur baru.

773. **Nightly Documentation Build**
     Proses otomatis membangun dan mempublikasikan dokumentasi (HTML, PDF) setiap malam untuk memastikan dokumentasi tetap sinkron dengan basis kode terbaru.

774. **Quick Fix**
     Perbaikan kecil yang diterapkan cepat untuk bug non-kritis atau kosmetik, sering kali tanpa melalui siklus QA penuh, dengan rilis patch segera.

775. **Template Literals**
     Sintaksis di beberapa bahasa (mis. JavaScript, Dart) untuk menyisipkan ekspresi ke dalam string dengan tanda backtick (`` `...${expr}...` ``), memudahkan pembuatan string dinamis.

776. **Spinlock**
     Mekanisme penguncian ringan di pemrograman konkuren di mana thread yang gagal memperoleh kunci akan terus memutar (_busy-wait_) loop pendek hingga kunci tersedia, cocok untuk proteksi singkat dengan overhead context switch rendah.

777. **Read–Write Lock (RWLock)**
     Sinkronisasi yang membedakan akses baca dan tulis: beberapa thread dapat membaca secara bersamaan (shared), tetapi penulisan eksklusif mengunci seluruh struktur sehingga penulis tunggal dapat beroperasi tanpa kontensi baca.

778. **Polling I/O**
     Teknik di mana aplikasi secara periodik memeriksa status perangkat I/O atau sumber data (mis. file descriptor) dalam loop, daripada menunggu notifikasi—sederhana tapi dapat membuang CPU jika interval terlalu pendek.

779. **Interrupt-Driven I/O**
     Mode I/O di mana perangkat keras mengirim sinyal _interrupt_ ke CPU saat data siap atau operasi selesai, memicu handler terjadwal tanpa perlu _busy-wait_, efisien untuk operasi variabel dan latency rendah.

780. **Callback Queue**
     Struktur data dalam event-driven environment (JavaScript, Node.js) yang menampung fungsi callback hingga _event loop_ siap mengeksekusinya setelah tugas I/O atau timer selesai, memisahkan eksekusi asynchronous dari _call stack_.

781. **Task Queue**
     Antrian yang menyimpan unit kerja terjadwal (tasks) dalam scheduler runtime (mis. tokio di Rust, asyncio di Python), di mana tiap task dijalankan saat loop siap, memungkinkan concurrency berbasis korutin.

782. **Premature Optimization**
     Anti-pola di mana pengembang menghabiskan usaha signifikan untuk optimasi performa sebelum algoritma dan arsitektur utama terbukti sebagai _bottleneck_, melanggar prinsip KISS dan mengorbankan keterbacaan.

783. **Micro-Optimization**
     Optimasi terperinci pada level instruksi atau baris kode (penggunaan operator bitwise, unrolling loop) yang memberikan keuntungan marginal, hanya dianjurkan setelah analisis profil menunjukkan area panas signifikan.

784. **Performance Budget**
     Batasan eksplisit pada metrik kinerja aplikasi (ukuran bundle, waktu muat, jumlah request) yang disepakati tim untuk menjaga pengalaman pengguna, memicu peringatan saat pelanggaran terjadi.

785. **Service Boundary**
     Garis definisi dalam arsitektur mikroservis yang menunjukkan ruang lingkup fungsional setiap layanan—menghindari tumpang tindih, memudahkan tim memilah tanggung jawab, dan mengurangi _coupling_ antar layanan.

786. **Data Contract**
     Kesepakatan formal antara penyedia dan konsumen layanan (API, event stream) tentang format dan semantik payload, versi, dan validasi, menjamin interoperabilitas dan evolusi mandiri tiap pihak.

787. **API Versioning**
     Strategi pengelolaan versi API (URL versioning, header versioning, media type versioning) untuk memungkinkan perubahan breaking tanpa memecah klien lama, dengan dokumentasi terperinci setiap versi.

788. **Content Negotiation**
     Mekanisme HTTP di mana klien dan server sepakat pada format respons (JSON, XML, HTML) melalui header seperti `Accept` dan `Content-Type`, memungkinkan API mendukung berbagai jenis klien.

789. **Soft Delete**
     Teknik penghapusan data di mana catatan hanya ditandai sebagai “dihapus” (flag `deleted_at` atau `is_deleted`) tanpa benar-benar dihapus dari basis data, memudahkan pemulihan dan audit histori.

790. **Hard Delete**
     Penghapusan permanen data dari penyimpanan (basis data, filesystem) tanpa jejak, mengurangi ukuran penyimpanan namun menghilangkan kemampuan rollback atau audit histori untuk entri tersebut.

791. **API Pagination**
     Pola API untuk mengembalikan data besar secara tersegmentasi—melalui parameter `limit`/`offset`, cursor-based, atau page-based—mengontrol beban server dan latensi klien untuk permintaan data berukuran besar.

792. **Rate Limit Header**
     Header HTTP (`X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`) yang menyampaikan kuota dan sisa permintaan klien, membantu klien menyesuaikan frekuensi panggilan agar tidak terblokir.

793. **Bulk Fetch/Update**
     Endpoint REST atau operasi query yang memungkinkan pengambilan atau pembaruan banyak entitas sekaligus (batch), memperkecil jumlah round-trip dan overhead otentikasi pada API.

794. **API Key**
     Token string yang dikeluarkan penyedia API untuk mengidentifikasi dan mengautentikasi aplikasi klien, dapat dipasangkan dengan rate limiting dan akses scoped untuk keamanan granular.

795. **Content Strategy**
     Perencanaan, pembuatan, distribusi, dan pemeliharaan konten teknis (dokumentasi, tutorial, blog), mencakup audiens, tone, format, dan siklus hidup konten agar aset pengetahuan tetap relevan dan mudah ditemukan.

796. **First-Class Function**
     Karakteristik bahasa pemrograman di mana fungsi diperlakukan sebagai nilai yang sama dengan tipe data lain—dapat disimpan dalam variabel, dilewatkan sebagai argumen, dan dikembalikan dari fungsi lain.

797. **Function Composition**
     Teknik menggabungkan dua atau lebih fungsi $f, g$ menjadi satu fungsi baru $h = f \circ g$ di mana output g menjadi input f, memungkinkan pembuatan alur transformasi data secara modular.

798. **Orthogonality**
     Prinsip desain sistem di mana komponen-komponen memiliki sedikit atau tidak ada ketergantungan satu sama lain, sehingga perubahan pada satu area tidak memengaruhi area lain, meningkatkan modularitas dan kemudahan pemeliharaan.

799. **Separation of Concerns (SoC)**
     Pendekatan arsitektur dan desain kode yang membagi sistem menjadi bagian-bagian berdikari (lapisan, modul, service) sesuai tanggung jawab fungsionalnya masing-masing, memudahkan pengembangan paralel dan isolasi bug.

800. **Coupling**
     Tingkat ketergantungan antar modul atau komponen:
     \- _Tight Coupling_: modul saling bergantung kuat, perubahan satu mempengaruhi yang lain.
     \- _Loose Coupling_: modul hanya berinteraksi melalui antarmuka terdefinisi, meminimalkan dampak perubahan internal.

801. **Cohesion**
     Derajat seberapa erat fungsi atau data dalam satu modul saling terkait:
     \- _High Cohesion_: elemen dalam modul bersama-sama melakukan tugas tunggal dengan baik.
     \- _Low Cohesion_: modul memuat tanggung jawab beragam, menyulitkan pemahaman dan pemeliharaan.

802. **Edge Case**
     Kondisi input atau penggunaan yang berada di batas ekstrim atau jarang terjadi—seperti nilai minimal/maksimal, urutan tak terduga, atau kegagalan dependensi—yang perlu diuji agar sistem tahan terhadap segala kemungkinan.

803. **Golden Path**
     Jalur eksekusi utama dan ideal dalam aplikasi atau API di mana semua langkah berhasil tanpa error atau validasi tambahan, mewakili skenario penggunaan paling umum.

804. **Onboarding Documentation**
     Dokumen atau panduan yang dirancang khusus untuk memperkenalkan pengembang baru kepada proyek: mencakup arsitektur sistem, proses setup, gaya penulisan kode, dan alur kontribusi, sehingga mereka dapat produktif lebih cepat.

805. **Interactive Documentation**
     Dokumentasi yang memungkinkan pengguna mencoba kode atau API secara langsung dalam halaman dokumentasi (mis. Swagger UI, Redoc, Playwright notebooks), menggabungkan deskripsi teks dengan formulir atau konsol live untuk eksperimen real-time.

806. **Development Environment**
     Konfigurasi perangkat lunak dan perangkat keras tempat pengembang menulis, menjalankan, dan menguji kode sebelum dipromosikan ke tahap selanjutnya. Umumnya mencakup IDE/editor, server lokal, database sampel, dan variabel lingkungan khusus.

807. **Staging Environment**
     Lingkungan pra-produksi yang secara dekat meniru kondisi produksi (konfigurasi, data, jaringan) untuk validasi akhir rilis dan pengujian integrasi penuh sebelum deployment ke pengguna akhir.

808. **Production Environment**
     Infrastruktur dan sistem di mana aplikasi atau layanan dijalankan untuk digunakan oleh pelanggan nyata. Perubahan di lingkungan ini harus melalui siklus release yang ketat untuk menjaga ketersediaan dan stabilitas.

809. **Test Suite**
     Kumpulan terorganisir dari test case yang dijalankan bersama untuk memverifikasi berbagai aspek aplikasi—unit, integrasi, fungsional, dan end-to-end—sering diotomasi dalam CI pipeline.

810. **Test Case**
     Deskripsi terstruktur skenario uji: input, langkah eksekusi, hasil yang diharapkan, dan kondisi lingkungan, untuk memverifikasi bahwa fungsionalitas spesifik bekerja sesuai spesifikasi.

811. **Test Plan**
     Dokumen formal yang merinci strategi, cakupan, sumber daya, jadwal, dan kriteria keberhasilan untuk aktivitas pengujian suatu proyek, memastikan koordinasi dan transparansi antar tim QA dan pengembang.

812. **Parameterized Testing**
     Teknik pengujian di mana satu test case dijalankan berkali-kali dengan berbagai kombinasi parameter atau data input, meningkatkan cakupan uji tanpa duplikasi kode.

813. **Blameless Postmortem**
     Proses dokumentasi insiden produksi di mana tim melakukan analisis kegagalan sistem secara terbuka dan tanpa mencari kesalahan individu, fokus pada perbaikan proses dan pencegahan ulang.

814. **Retrospective Meeting**
     Ritual Scrum atau Agile di akhir sprint di mana tim merefleksikan apa yang berjalan baik, apa yang bisa diperbaiki, dan menyusun rencana tindakan untuk sprint berikutnya.

815. **Daily Standup**
     Pertemuan singkat harian (biasanya 15 menit) di tim Agile di mana setiap anggota menjelaskan progres kemarin, rencana hari ini, dan hambatan yang dihadapi, menjaga visibilitas dan koordinasi.

816. **Risk Register**
     Daftar terstruktur risiko teknis dan manajerial—setiap entri mencakup deskripsi risiko, probabilitas, dampak, mitigasi, dan penanggung jawab—peringatan dini untuk mengelola ketidakpastian proyek.

817. **Root Cause Analysis**
     Metode investigasi yang menelusuri sumber paling mendasar dari suatu bug atau insiden (mis. _5 Whys_, _Fishbone Diagram_) untuk memastikan solusi menanggulangi penyebab, bukan gejala.

818. **Audience Analysis**
     Proses sistematis mengidentifikasi karakteristik, kebutuhan, dan tingkat keahlian pembaca dokumentasi atau pengguna API, agar konten disusun dengan gaya dan detail yang tepat.

819. **UX Writing**
     Praktik menulis teks antarmuka pengguna (microcopy) seperti label tombol, notifikasi, dan petunjuk interaksi yang memandu pengguna secara jelas, ringkas, dan bersahabat.

820. **Microcopy**
     Potongan teks singkat di aplikasi atau situs—seperti tombol, placeholder, pesan kesalahan—yang krusial untuk pengalaman pengguna, sering kali ditulis dengan cermat untuk mengurangi kebingungan.

821. **Tooltip**
     Pesan bantu singkat yang muncul saat pengguna mengarahkan kursor ke elemen UI tertentu, memberikan konteks tambahan atau penjelasan fungsi tanpa mengacaukan antarmuka utama.

822. **Knowledge Base**
     Kumpulan artikel, FAQ, dan panduan terstruktur yang mendokumentasikan pengetahuan teknis dan solusi atas masalah umum, memudahkan tim dukungan dan pengguna mandiri dalam menemukan jawaban.

823. **Content Governance**
     Kerangka kerja kebijakan, peran, dan proses untuk mengelola pembuatan, review, penerbitan, dan pemeliharaan konten dokumentasi, memastikan konsistensi, akurasi, dan kepatuhan organisasi.

824. **Version Control for Documentation**
     Penggunaan sistem kontrol versi (Git, Mercurial) untuk menyimpan, melacak, dan mengelola revisi file dokumentasi—memungkinkan kolaborasi, review, dan rollback perubahan teks.

825. **Content Audit**
     Evaluasi komprehensif terhadap aset dokumentasi atau situs—mencakup penilaian relevansi, keusangan, duplikasi, dan kualitas—sebagai dasar untuk perbaikan struktur dan pemutakhiran konten.

826. **Executable Documentation**
     Dokumentasi yang tidak hanya bersifat deskriptif, tetapi juga dapat dijalankan—misalnya notebook atau skrip—sehingga pembaca dapat melihat hasil nyata (output) sambil membaca penjelasan.

827. **Doc-as-Code**
     Pendekatan pengelolaan dokumentasi menggunakan alat dan alur kerja pengembangan perangkat lunak (Git, CI/CD, review) sama seperti kode sumber, memanfaatkan sistem version control dan kolaborasi tim.

828. **Static Site Generator**
     Alat yang mengonversi sumber konten (Markdown, AsciiDoc, reST) dan templat menjadi situs web statis (HTML/CSS/JS) untuk dokumentasi atau blog, tanpa kebutuhan server dinamis—contoh: Jekyll, Hugo, MkDocs.

829. **MkDocs**
     Static site generator berbasis Python khusus untuk dokumentasi, menggunakan Markdown dan konfigurasi YAML sederhana, serta mendukung tema dan plugin komunitas.

830. **Docusaurus**
     Framework dokumentasi berbasis React oleh Facebook, mengubah Markdown menjadi situs statis yang mendukung versioning, pencarian, dan i18n secara bawaan.

831. **Hugo**
     Static site generator yang ditulis dalam Go, terkenal karena build time sangat cepat, mendukung struktur konten fleksibel, taxonomies, dan templating Go.

832. **Read the Docs**
     Layanan hosting dokumentasi otomatis yang menarik repositori Git, membangun dengan Sphinx atau MkDocs, dan mempublikasikan hasil penggunaannya di subdomain `readthedocs.io`.

833. **Front Matter**
     Metadata di bagian atas berkas Markdown atau AsciiDoc (biasanya ditandai oleh `---`), berisi informasi seperti judul, penulis, tanggal, dan pengaturan rendering yang digunakan oleh static site generator.

834. **Cell Output**
     Hasil yang dihasilkan oleh cell kode di notebook (grafik, tabel, teks), ditampilkan langsung di bawah cell, memungkinkan kombinasi narasi dan eksperimen interaktif.

835. **Kernel**
     Proses backend yang mengeksekusi kode di notebook (Jupyter, nteract); tiap kernel mendukung bahasa tertentu (Python, R, Julia) dan bertanggung jawab atas eksekusi perintah serta manajemen state.

836. **Binder**
     Layanan cloud yang secara otomatis membangun dan menjalankan lingkungan notebook interaktif dari repositori GitHub, memungkinkan siapa saja mencoba kode tanpa setup lokal.

837. **Pandoc Filter**
     Ekstensi (Lua, Haskell, Python) yang memodifikasi abstraksi dokumen Pandoc (AST) saat konversi antar format, memudahkan transformasi khusus seperti penyisipan diagram atau penyesuaian pemformatan.

838. **Snippet Manager**
     Alat (editor plugin atau standalone) untuk menyimpan, mengatur, dan memanggil kembali potongan kode (snippet) yang sering digunakan, dengan kategori dan tag untuk mempercepat penulisan.

839. **Content Chunking**
     Teknik penulisan di mana informasi dibagi ke dalam bagian-bagian logis kecil (chunk) dengan heading, daftar, atau kartu informasi, memudahkan pembaca mencerna dan memindai dokumen panjang.

840. **Sectioning**
     Pendekatan struktur dokumen teknis dengan pembagian hierarkis (bab, bagian, subbagian) menggunakan heading berjenjang (`<h1>`–`<h6>` atau `#`–`######` di Markdown) untuk navigasi dan TOC otomatis.

841. **API Playground**
     Antarmuka interaktif—biasanya web—yang memungkinkan pengguna bereksperimen langsung dengan endpoint API melalui form, mengirim permintaan, dan melihat respons JSON/XML nyata.

842. **GraphQL Playground**
     Editor berbasis web untuk API GraphQL yang menyediakan autocompletion, dokumentasi skema interaktif, dan kemampuan menjalankan query atau mutation secara langsung.

843. **Postman Collection**
     Kumpulan definisi request API (URL, header, body, test script) yang disimpan dalam Postman, dapat dibagikan, dieksekusi secara otomatis, atau digunakan dalam CI pipeline untuk validasi integrasi.

844. **Insomnia**
     Aplikasi cross-platform untuk testing dan debugging API (REST, GraphQL), menawarkan workspace terorganisir, environment variables, dan plugin ecosystem untuk kebutuhan dokumentasi dan otomasi.

845. **Template Fragment**
     Baris atau blok markup (HTML, JSX, Handlebars) yang disimpan sebagai komponen atau partial dan di-_include_ di beberapa halaman, mempromosikan reuse dan konsistensi tampilan dokumentasi atau aplikasi.

846. **Notebook Viewer**
     Alat atau platform yang memungkinkan melihat file notebook (Jupyter, Zeppelin) sebagai dokumen statis—menampilkan sel kode dan output—tanpa perlu eksekusi ulang atau instalasi lingkungan.

847. **API Mocking**
     Teknik membuat server palsu (mock server) untuk meniru perilaku API yang sebenarnya, memungkinkan pengembangan frontend atau integrasi diuji tanpa ketergantungan ke backend yang belum selesai.

848. **Schema Registry**
     Layanan terpusat untuk mengelola dan memvalidasi skema data (Avro, JSON Schema, Protobuf) yang digunakan dalam sistem streaming atau event-driven, memastikan kompatibilitas produsen dan konsumen.

849. **Code Playground Embedding**
     Menyematkan lingkungan interaktif (CodeSandbox, StackBlitz, DartPad) langsung ke dokumentasi web atau blog agar pembaca dapat bereksperimen dengan kode tanpa meninggalkan halaman.

850. **Documentation Portal**
     Situs terintegrasi yang menggabungkan referensi API, tutorial, FAQ, dan kelompok konten lain dalam satu antarmuka terpadu, sering dengan navigasi sidemenu, pencarian global, dan branding konsisten.

851. **Versioned Documentation**
     Praktik menyediakan beberapa versi dokumentasi sesuai rilis perangkat lunak, memungkinkan pembaca memilih dokumentasi yang cocok dengan versi aplikasi atau API yang mereka gunakan.

852. **Interactive CLI Wizard**
     Program command-line yang memandu pengguna melalui serangkaian pertanyaan interaktif (prompts) untuk mengonfigurasi proyek, menghasilkan boilerplate, atau menjalankan setup tanpa perlu membaca dokumentasi panjang.

853. **Containerized Documentation**
     Mendefinisikan lingkungan dokumentasi (MkDocs, Docusaurus, Sphinx) dalam container Docker sehingga siapa pun dapat menjalankan build dan preview secara konsisten tanpa menginstal dependensi global.

854. **Live Preview**
     Fitur editor atau static site generator yang memperbarui tampilan dokumentasi secara real-time saat penulis menyimpan perubahan pada sumber—mempercepat iterasi penulisan dan layout tweaking.

855. **Content Localization Workflow**
     Alur kerja terstruktur untuk menerjemahkan dokumentasi atau antarmuka aplikasi, mencakup ekstraksi string, manajemen proyek terjemahan (Crowdin, Transifex), review QA, dan integrasi kembali ke repositori.

856. **ETag (Entity Tag)**
     Token unik yang diberikan server dalam header HTTP `ETag` untuk mewakili versi spesifik dari suatu sumber daya. Klien dapat mengirim kembali nilai ETag di header `If-None-Match` untuk memeriksa apakah konten telah berubah, sehingga menghemat bandwidth dengan memungkinkan respons `304 Not Modified`.

857. **Last-Modified Header**
     Header HTTP yang menunjukkan tanggal dan waktu terakhir kali sumber daya diubah. Klien dapat menggunakan header `If-Modified-Since` untuk meminta konten hanya jika telah berubah sejak timestamp tersebut, mendukung caching kondisional.

858. **Named Capture Group**
     Fitur pada regex modern yang memungkinkan Anda memberi nama pada grup penangkapan, misalnya `(?<year>\d{4})`, sehingga hasil yang diekstrak dapat diakses dengan identifier `year` alih-alih indeks numerik.

859. **Lookahead Assertion**
     Metakarakter pada regex untuk memeriksa bahwa suatu pola diikuti (positive lookahead `(?=…)`) atau tidak diikuti (negative lookahead `(?!…)`) oleh pola lain, tanpa ikut mengonsumsi karakter dalam pencocokan.

860. **Lookbehind Assertion**
     Metakarakter pada regex untuk memeriksa bahwa suatu posisi diapit (positive lookbehind `(?<=…)`) atau tidak diapit (negative lookbehind `(?<!…)`) oleh pola tertentu sebelum titik pencocokan, tanpa memakan karakter tersebut.

861. **Backreference**
     Referensi ulang di dalam regex ke teks yang ditangkap oleh grup sebelumnya, ditandai dengan `\1`, `\2`, atau nama grup (`\k<name>`), memudahkan pencocokan pola berulang atau simetri dalam string.

862. **Unicode Code Point**
     Nilai bilangan bulat unik (U+0000 hingga U+10FFFF) yang mewakili karakter abstrak dalam standar Unicode, terpisah dari encoding aktual (UTF-8, UTF-16).

863. **Grapheme Cluster**
     Satuan teks yang dirasakan pengguna sebagai satu karakter (mis. huruf + tanda diakritik) meski pada level kode ada beberapa code point—penting untuk iterasi teks dan operasi substring yang ramah pengguna.

864. **Zero-Width Joiner (ZWJ)**
     Karakter kontrol Unicode (U+200D) yang mengindikasikan penggabungan glyph terpisah menjadi satu ligatur visual, digunakan misalnya pada emoji yang mengkombinasikan beberapa simbol.

865. **Bidirectional Text (BiDi)**
     Mekanisme penanganan teks campuran arah kanan-ke-kiri (mis. Arab, Ibrani) dan kiri-ke-kanan (mis. Latin) menggunakan algoritma Unicode BiDi untuk menentukan urutan tampilan yang benar.

866. **Zero-Width Non-Joiner (ZWNJ)**
     Karakter kontrol Unicode (U+200C) yang mencegah ligatur atau penggabungan glyph, menjaga dua karakter tetap terpisah secara visual meski secara normal akan bergabung.

867. **Soft Hyphen**
     Karakter kontrol (U+00AD) yang menunjukkan titik pemenggalan kata opsional; hanya terlihat dan dipakai oleh renderer teks saat kata perlu dipatahkan di akhir baris.

868. **Byte Order Mark (BOM)**
     Urutan byte (mis. 0xEF,0xBB,0xBF untuk UTF-8) di awal berkas teks yang menunjukkan encoding Unicode, membantu aplikasi mendeteksi format pengkodean meski kadang menimbulkan masalah saat tidak diharapkan.

869. **Normalization Form (NFC/NFD/NFKC/NFKD)**
     Metode standar Unicode untuk menyatukan representasi karakter:
     \- _NFC_: Canonical Composition.
     \- _NFD_: Canonical Decomposition.
     \- _NFKC/NFKD_: Compatibility variants with pemetaan karakter tambahan.

870. **[Code Point Escape][escape]**
     Sintaks di bahasa pemrograman atau regex untuk mewakili karakter Unicode berdasarkan kode titiknya, mis. `\u{1F600}` atau `\U0001F600` untuk emoji.

871. **PCL (Printer Command Language)**
     Bahasa perintah untuk mengendalikan printer laser/shock­wave, mengekspresikan layout halaman, jenis font, dan grafis dalam dokumen—umum pada printer HP.

872. **Rich Text Format (RTF)**
     Format dokumen teks yang menyertakan markup gaya (font, paragraf, warna) dalam teks ASCII yang dapat dibaca, didukung lintas platform dan aplikasi.

873. **Control Character**
     Unicode atau ASCII code point non-cetak (mis. U+0000–U+001F, U+007F) yang mengendalikan alur teks (newline, tab, carriage return) atau format device.

874. **End-of-Line Sequence**
     Urutan karakter yang menandai akhir baris teks:
     \- _LF_ (`\n`) di Unix/Linux/macOS.
     \- _CRLF_ (`\r\n`) di Windows.
     \- _CR_ (`\r`) di klasik Mac OS.

875. **Text Encoding Detection**
     Proses atau algoritma (mis. BOM sniffing, heuristic) untuk menentukan encoding teks berbasiskan byte patterns dan statistik, mencegah mojibake saat membaca file.

876. **Font Fallback**
     Mekanisme sistem operasi atau aplikasi untuk menggantikan glyph yang tidak tersedia dalam font utama dengan glyph dari font lain, memastikan teks Unicode lengkap dapat ditampilkan.

877. **Ligature**
     Penggabungan dua atau lebih karakter (mis. “fi”, “fl”) menjadi satu glyph tunggal untuk estetika tipografi, dikendalikan via font OpenType.

878. **Kerning**
     Penyesuaian spasi horizontal antara pasangan huruf tertentu untuk peningkatan keterbacaan dan estetika teks, diatur melalui data font.

879. **Hinting**
     Instruksi pada font vector yang membantu rasterizer memposisikan dan merender glyph dengan jelas pada ukuran piksel rendah atau ukuran teks kecil.

880. **OpenType Feature**
     Set fitur tipografi lanjutan dalam font (liga, alternatif kontekstual, gaya swash) yang dapat diaktifkan melalui CSS atau aplikasi untuk efek huruf khusus.

881. **Dark Mode / Light Mode**
     Skema warna antarmuka dan dokumentasi di mana teks dan latar belakang diatur agar kontras optimal—Light Mode (tinta gelap di atas latar terang) atau Dark Mode (sebaliknya)—meningkatkan kenyamanan baca di berbagai kondisi.

882. **High DPI Support**
     Kemampuan aplikasi dan dokumentasi web untuk menampilkan teks dan grafis tajam pada layar dengan densitas piksel tinggi, menggunakan font dan gambar vektor atau multiple-resolution bitmap.

883. **ARIA (Accessible Rich Internet Applications)**
     Kumpulan atribut HTML yang memberi informasi aksesibilitas (role, state, properties) untuk komponen interaktif, memudahkan screen reader dan alat bantu memahami struktur dan fungsi UI.

884. **WCAG (Web Content Accessibility Guidelines)**
     Standar internasional untuk membuat konten web dapat diakses oleh pengguna berkebutuhan khusus, mencakup prinsip: Perceivable, Operable, Understandable, Robust (POUR).

885. **Semantic HTML**
     Penggunaan elemen HTML yang bermakna (`<article>`, `<nav>`, `<section>`, `<header>`) untuk menstruktur konten secara logis, meningkatkan SEO, aksesibilitas, dan keterbacaan kode.

886. **Microdata / JSON-LD / RDFa**
     Format penandaan data terstruktur dalam HTML untuk mendeskripsikan objek (Produk, Artikel) dan relasi, mendukung mesin pencari memahami konten halaman lewat schema.org vocabulary.

887. **Lazy Loading**
     Teknik menunda pemuatan sumber daya (gambar, skrip, modul UI) hingga benar-benar diperlukan—mis. saat elemen muncul dalam viewport—mengurangi beban muat awal dan meningkatkan performa halaman.

888. **Responsive Typography**
     Pendekatan menyesuaikan ukuran font secara dinamis berdasarkan lebar viewport atau preferensi pengguna (CSS `clamp()`, `vw` units), menjaga keterbacaan di berbagai perangkat.

889. **Line Height (Leading)**
     Jarak vertikal antara garis dasar (baseline) teks berturut-turut, diatur melalui CSS `line-height` untuk meningkatkan keterbacaan dan estetika paragraf.

890. **Hyphenation**
     Pemenggalan kata otomatis di akhir baris berdasarkan aturan bahasa, dapat diaktifkan via CSS `hyphens: auto` atau library tipografi untuk mencegah ruang putih besar.

891. **Justified Text**
     Penyelarasan teks di kedua tepi kiri dan kanan kolom, menyesuaikan spasi antar kata/glyph agar margin rapi; memerlukan pengaturan kerning dan hyphenation untuk menghindari rivers of white.

892. **Widow and Orphan Control**
     Teknik tipografi untuk mencegah baris tunggal di awal (orphan) atau akhir (widow) paragraf terpisah di halaman atau kolom, meningkatkan alur baca visual.

893. **Pull Quote**
     Potongan teks penting yang ditarik dari paragraf utama untuk diletakkan di margin atau area terpisah dengan gaya khusus, menarik perhatian pembaca dan memecah teks panjang.

894. **Admonition**
     Blok informasi bergaya (catatan, peringatan, tips, petunjuk) dalam dokumentasi (Sphinx, MkDocs) dengan ikon dan warna khusus untuk menyoroti hal penting atau bahaya.

895. **Callout**
     Elemen visual atau teks dalam dokumentasi yang menampilkan kutipan kunci, contoh singkat, atau peringatan, memudahkan pembaca menangkap poin esensial tanpa membaca paragraf penuh.

896. **Interactive Example**
     Potongan kode yang dapat dijalankan langsung di dokumentasi—mis. via embedded REPL atau sandbox—untuk memudahkan pembaca mempelajari API atau library secara praktis.

897. **API Changelog**
     Dokumen terpisah yang merinci perubahan spesifik pada versi-versi API (endpoint ditambahkan/dihapus, parameter berubah), membantu konsumen menyesuaikan kode mereka.

898. **Endpoint Discovery**
     Fitur API di mana daftar endpoint, metode, dan skema respons dapat diperoleh secara dinamis—mis. via OpenAPI spec di `/openapi.json`—memudahkan tooling otomatis dan klien dinamis.

899. **Content Security Policy (CSP)**
     Header HTTP (`Content-Security-Policy`) yang mengatur sumber konten yang diizinkan (script, style, gambar, font), mencegah _cross-site scripting_ dan _data injection_.

900. **Subresource Integrity (SRI)**
     Mekanisme keamanan web di mana tag `<script>` atau `<link>` menyertakan atribut `integrity="sha256-..."` untuk memverifikasi bahwa sumber eksternal tidak diubah.

901. **Immutable Cache Header**
     Kombinasi header HTTP (`Cache-Control: immutable, max-age=...`) yang memberi tahu browser bahwa aset versi-tersemat tidak akan berubah, sehingga dapat disimpan dalam cache jangka panjang.

902. **Diffusion of Responsibility**
     Anti-pola dokumentasi di mana tidak ada satu pun individu atau tim yang merasa bertanggung jawab atas pemutakhiran dokumentasi, menyebabkan konten cepat usang.

903. **Editorial Calendar**
     Jadwal terstruktur publikasi konten dokumentasi, blog, dan tutorial, membantu tim merencanakan topik, penulis, dan tanggal rilis untuk menjaga konsistensi.

904. **Living Style Guide**
     Dokumentasi interaktif yang menampilkan komponen UI, pola desain, dan panduan tipografi secara real-time (serupa _pattern library_), memudahkan konsistensi front-end.

905. **Pattern Lab**
     Toolset dan metodologi untuk membangun living style guide berbasis _Atomic Design_, memecah UI menjadi atom, molekul, dan organisme yang dapat dikomposisi.

906. **Atomic Design**
     Pendekatan desain UI yang memecah antarmuka menjadi komponen terkecil (atom), digabung menjadi molekul, organisme, dan template, hingga halaman penuh, untuk reuse terstruktur.

907. **Design Token**
     Variabel terpusat (warna, ukuran font, spasi) yang terdefinisi dalam format JSON atau YAML, digunakan di kode front-end dan dokumentasi untuk konsistensi branding dan UI.

908. **Sketch File**
     Berkas desain UI dari aplikasi Sketch yang menyertakan artboards, simbol, dan style guide, dapat diekspor ke developer untuk referensi implementasi.

909. **Figma Prototype**
     Model interaktif dibuat di Figma, memungkinkan stakeholder mencobakan alur UI tanpa coding, serta mengekspor spesifikasi CSS dan aset grafis.

910. **Zeplin Handoff**
     Platform yang menghubungkan desainer dan developer, mengonversi desain Figma/Sketch ke spesifikasi kode, styleguide, dan aset siap pakai secara otomatis.

911. **Storybook**
     Framework untuk mengembangkan dan mendokumentasikan komponen UI React/Vue/Angular secara isolasi, menampilkan _stories_ (skenario) yang dapat dijalankan dan diuji.

912. **UI Kit**
     Kumpulan komponen antarmuka prasetel (button, form, modal) dalam library atau desain system, disertai dokumentasi cara penggunaan dan varian.

913. **Cognitive Dimensions Framework**
     Pendekatan evaluasi desain tool atau bahasa pemrograman berdasarkan keserbagunaan, learnability, dan kebebasan eksplorasi, membantu mengukur kemudahan penggunaan.

914. **API Rate Limit Exceeded**
     Respons HTTP `429 Too Many Requests` ketika klien melampaui batas permintaan yang ditetapkan, sering disertai header `Retry-After` untuk memberi tahu kapan boleh mencoba lagi.

915. **Retry-After Header**
     Header HTTP yang menyertakan durasi (detik atau timestamp) di mana klien harus menunggu sebelum mengulangi permintaan setelah menerima `429` atau `503`.

916. **Circuit Breaker Fallback**
     Mekanisme skenario cadangan yang dijalankan saat circuit breaker terbuka—mis. mengembalikan nilai default atau meneruskan ke cache—untuk menjaga pengalaman pengguna tetap responsif.

917. **Graceful Shutdown**
     Proses penutupan aplikasi atau layanan yang menolak permintaan baru, menyelesaikan permintaan berjalan, melepaskan koneksi, dan menyimpan state sebelum terminasi.

918. **Health Endpoint**
     Jalur API khusus (mis. `/healthz`, `/status`) yang mengembalikan status JSON komponen layanan (database, cache, dependencies), digunakan oleh orkestrator dan load balancer.

919. **Feature Preview**
     Fitur eksperimental yang diaktifkan untuk sebagian kecil pengguna via flag, memungkinkan umpan balik awal sebelum peluncuran umum.

920. **Experiment Flag**
     Bendera boolean dalam konfigurasi atau kode (mis. LaunchDarkly, FeatureFlags) yang mengaktifkan eksperimen A/B atau fitur preview pada runtime.

921. **Data Dog Integration**
     Pengiriman metrics, traces, dan logs ke layanan DataDog melalui agen atau SDK untuk observability terpusat, dashboard, dan alerting sesuai SLI/SLO.

922. **OpenAPI Generator**
     Tool yang menghasilkan klien, server stub, atau dokumentasi dari file OpenAPI (`.yaml`/`.json`), mendukung berbagai bahasa pemrograman dan framework.

923. **GraphQL Code Generator**
     Alat otomasi yang menghasilkan tipe statis (TypeScript, Flow) dan query/mutation client berdasarkan skema GraphQL dan dokumen `.graphql`, meningkatkan keamanan tipe.

924. **Schema Stitching**
     Teknik menggabungkan beberapa skema GraphQL menjadi satu endpoint terpusat, memudahkan agregasi data dari mikroservis independen.

925. **GraphQL Federation**
     Pola federasi resmi yang menggunakan subgraph SDL dan gateway (Apollo Federation) untuk menyusun skema GraphQL terdistribusi dengan resolusi lintas-layanan.

926. **Intent-Driven Testing**
     Pendekatan menulis test berdasarkan perilaku bisnis atau tujuan pengguna (_intent_), alih-alih implementasi teknis, menghasilkan suite yang lebih tahan terhadap refaktor kode.

927. **Mutation Observer**
     API browser (`MutationObserver`) yang memantau perubahan DOM (atribut, childList, subtree) dan menjalankan callback saat mutasi terdeteksi, mendukung reaktivitas custom.

928. **Intersection Observer**
     API browser (`IntersectionObserver`) yang memberi tahu saat elemen memasuki atau meninggalkan viewport, memudahkan implementasi lazy loading dan animasi scroll-based.

929. **Resize Observer**
     API browser (`ResizeObserver`) yang memantau perubahan ukuran elemen dan memicu callback, berguna untuk layout dinamis dan responsif.

930. **Service Worker Lifecycle**
     Tahapan dalam siklus hidup Service Worker—`install`, `activate`, `fetch`, `message`—dengan event handler khusus untuk caching, update, dan interaksi dengan page clients.

931. **Push Notification Subscription**
     Proses mendaftar Service Worker dan endpoint push (Push API) bersama kredensial (VAPID key), memungkinkan server mengirim notifikasi ke browser pengguna meski tab tertutup.

932. **Web Share API**
     API browser yang memungkinkan halaman web memanggil dialog berbagi asli OS (text, URL, file) ke aplikasi lain, meningkatkan integrasi mobile-like pada web.

933. **Payment Request API**
     Standar web untuk mengintegrasikan metode pembayaran (kartu, dompet digital) di browser secara terpadu, memfasilitasi checkout cepat dan aman.

934. **Credential Management API**
     API web yang membantu aplikasi mengelola kredensial (password, federated login) di browser, mendukung _autofill_ dan single sign-on terintegrasi.

935. **Digital Asset Links**
     Mekanisme Android dan web untuk memverifikasi hubungan antara domain web dan aplikasi Android melalui file JSON di `/.well-known/assetlinks.json`, mendukung _app links_ dan _deep linking_.

936. **App Shell Architecture**
     Pola PWA di mana kerangka dasar UI di-cache dan dihidupkan secara instan, lalu konten dinamis di-_hydrate_, memberikan pengalaman startup cepat dan offline-first.

937. **Workbox**
     Library JavaScript oleh Google yang menyederhanakan pembuatan Service Worker, caching strategi, dan runtime routing untuk Progressive Web App.

938. **Preload vs Prefetch**
     Resource hints di HTML:
     \- `<link rel="preload">`: memuat sumber daya kritis segera untuk kinerja.
     \- `<link rel="prefetch">`: memuat sumber daya non-kritis saat idle untuk penggunaan masa depan.

939. **Prerendering**
     Teknik di mana browser atau tool server-side merender halaman lengkap sebelum permintaan pengguna, menyimpan hasil HTML dan JS untuk waktu-muat instan.

940. **Sitemap XML**
     Berkas `sitemap.xml` di situs web yang mendeskripsikan struktur URL dan metadata (_lastmod_, _changefreq_, _priority_) untuk konsumsi mesin pencari dan optimasi SEO.

941. **Robots.txt**
     Berkas di root situs web (`/robots.txt`) yang memberikan instruksi pada _crawler_ mesin pencari (User-agent) tentang halaman yang boleh atau tidak boleh diindeks.

942. **Canonical Link Element**
     Tag HTML `<link rel="canonical" href="URL">` yang memberi tahu mesin pencari versi URL utama untuk menghindari konten duplikat dan menyatukan ranking.

943. **Open Graph Protocol**
     Standar metadata (`<meta property="og:...">`) untuk menyertakan judul, deskripsi, gambar saat halaman dibagikan di media sosial, meningkatkan tampilan _rich preview_.

944. **Twitter Card**
     Metadata (`<meta name="twitter:...">`) serupa Open Graph khusus untuk Twitter, mengontrol tampilan kartu (summary, player, image) saat URL dibagikan.

945. **Schema.org Markup**
     Koleksi skema data terstruktur (JSON-LD, Microdata) untuk mendeskripsikan objek seperti Artikel, Produk, Event di halaman web, membantu mesin pencari meningkatkan _rich snippet_.

946. **RDF Triple**
     Unit dasar dalam Resource Description Framework (RDF) yang menyatakan fakta sebagai tiga komponen: _subject_, _predicate_, dan _object_—memodelkan relasi semantik dalam graf pengetahuan.

947. **SPARQL**
     Query language standar untuk mengambil dan memanipulasi data yang diwakili sebagai RDF triple, mendukung pola pencocokan graf, federasi endpoint, dan konstruksi kembali data.

948. **Linked Data**
     Prinsip publikasi data terstruktur di web dengan menggunakan URIs yang dapat di-resolve, RDF, dan relasi _owl\:sameAs_ untuk menghubungkan sumber data terdistribusi menjadi web semantik.

949. **OWL (Web Ontology Language)**
     Bahasa formal untuk mendefinisikan dan berbagi ontologi—model konsep dan relasi dalam domain—dengan kemampuan inferensi logis untuk mengekstrak pengetahuan baru dari data RDF.

950. **Semantic Web**
     Ekstensi dari Web di mana informasi dipublikasikan dalam format terstruktur (RDF, OWL) sehingga mesin dapat “mengerti” makna konten, memfasilitasi agen cerdas, pencarian kontekstual, dan integrasi data otomatis.

951. **JSON-LD Context**
     Bagian dari dokumen JSON-LD (`"@context"`) yang mendefinisikan penamaan (prefix) dan pemetaan istilah ke URIs penuh, memungkinkan data terstruktur menjadi bermakna di web semantik.

952. **RDFa Lite**
     Subset sederhana RDFa untuk menanamkan data terstruktur dalam HTML dengan atribut minimal (`typeof`, `property`, `resource`), memudahkan authoring linked data tanpa kompleksitas penuh RDFa.

953. **Microformats**
     Spesifikasi untuk menandai konten HTML menggunakan kelas dan atribut standar (mis. `h-card`, `h-entry`) agar data semantik sederhana dapat diekstraksi oleh user agent dan crawler.

954. **JSON Schema Validation**
     Proses memeriksa bahwa dokumen JSON mematuhi aturan yang ditentukan dalam JSON Schema—tipe, pola string, batas numerik, referensi silang—untuk memastikan format dan data konsisten.

955. **SHACL (Shapes Constraint Language)**
     Bahasa untuk mendefinisikan dan memvalidasi “shapes” pada data RDF—membatasi tipe node, properti wajib, dan nilai pola—memastikan data linked data sesuai model domain.

956. **SKOS (Simple Knowledge Organization System)**
     Model RDF untuk memodelkan taksonomi, tesaurus, dan skema pengindeksan pengetahuan dengan konsep (`skos:Concept`), hubungan hierarkis, dan notasi skema istilah.

957. **Content Negotiation Profile**
     Ekstensi HTTP yang memungkinkan klien mempublikasikan preferensi format, bahasa, atau skema metadata secara lebih terperinci melalui header `Profile`, mendukung variasi representasi sumber daya.

958. **HTTP Link Header**
     Header HTTP (`Link`) yang menyisipkan metadata hubungan antar sumber daya (relasi `next`, `prev`, `alternate`, `describedby`), mendukung navigasi, pagination, dan dokumentasi API tersemat.

959. **WASM Text Format (WAT)**
     Representasi teks human-readable dari modul WebAssembly (`.wat`), yang kemudian dikompilasi menjadi format biner (`.wasm`) untuk eksekusi di browser atau runtime WASM.

960. **WebIDL**
     Interface Definition Language yang digunakan untuk mendefinisikan antarmuka JavaScript API browser (DOM, Web APIs), menjadi dasar untuk binding otomatis antara engine dan implementasi.

961. **Actor Model Concurrency**
     Paradigma pemrograman di mana “aktor” adalah unit eksekusi independen yang berkomunikasi hanya melalui pesan asinkron, menghindari shared memory dan memudahkan skalabilitas terdistribusi.

962. **Bulkhead Isolation**
     Pola keandalan di mana sumber daya (thread pool, connection pool) dibagi per-komponen sehingga kegagalan satu layanan atau modul tidak merembet ke layanan lainnya.

963. **Chaos Engineering Experiment**
     Definisi terstruktur (skenario, asumsi, metrik, pencegahan risiko) untuk mengintroduksi gangguan terkendali ke sistem produksi guna menguji ketahanan dan self-healing.

964. **Domain-Specific Language (DSL)**
     Bahasa pemrograman atau sintaks khusus yang didesain untuk menangani permasalahan dalam domain tertentu secara lebih ekspresif dan ringkas daripada bahasa umum.

965. **Feature Flag Management**
     Sistem terpusat untuk mendefinisikan, mengelola, dan mengaudit feature flags—termasuk rollout rules, audience targeting, dan analytics—tanpa deploy ulang aplikasi.

966. **Immutable Log**
     Struktur penyimpanan data di mana setiap entri hanya dapat ditambahkan dan tidak pernah dimodifikasi atau dihapus, sering dipakai untuk audit trail dan sistem event sourcing.

967. **Over-The-Air (OTA) Update**
     Mekanisme pengiriman pembaruan perangkat lunak secara remote (firmware, aplikasi mobile/IoT) tanpa memerlukan intervensi manual pada perangkat akhir.

968. **Progressive Enhancement**
     Strategi pengembangan web yang memastikan konten dasar dan fungsionalitas bekerja pada semua browser, kemudian menambahkan fitur canggih (JavaScript, CSS3) jika didukung.

969. **Service Blueprint**
     Dokumen atau diagram yang memetakan alur pengalaman pengguna bersama proses bisnis backend, touchpoint, dan sistem pendukung untuk mengoptimalkan layanan end-to-end.

970. **Zero Downtime Migration**
     Teknik pindah data atau upgrade skema—seperti dual‐write, feature toggles, dan backfill asinkron—tanpa menghentikan akses produksi, menjamin kontinuitas layanan.

971. **Consistent Hashing**
     Algoritma pembagian beban pada _distributed cache_ atau shard database yang memetakan kunci ke node secara merata, dengan minimalisasi _reshuffling_ ketika node bergabung atau ditinggalkan.

972. **Rendezvous (Highest Random Weight) Hashing**
     Teknik pemilihan node deterministik untuk suatu kunci dalam sistem terdistribusi, di mana setiap node menghitung skor acak berdasarkan key, dan kunci diarahkan ke node dengan skor tertinggi.

973. **Quorum Read/Write**
     Strategi pada sistem terdistribusi di mana operasi baca/tulis memerlukan persetujuan mayoritas (quorum) dari replika untuk menjamin konsistensi tertentu sesuai model CAP.

974. **Stale-While-Revalidate**
     Kebijakan caching HTTP di mana respons cache lama boleh digunakan sementara salinan baru diambil di latar belakang, meminimalkan latensi sambil tetap menyegarkan data.

975. **Debounce**
     Pola pemrograman _event handler_ yang menunda pelaksanaan fungsi hingga setelah jeda waktu tertentu sejak pemanggilan terakhir, mengurangi frekuensi panggilan pada input yang cepat berubah (scroll, resize).

976. **Throttle**
     Teknik kontrol frekuensi _event handler_ yang memastikan fungsi hanya dipanggil sekali setiap interval waktu tetap, mencegah beban berlebihan pada event yang bersifat _high-frequency_.

977. **LRU Cache (Least Recently Used)**
     Kebijakan penggantian cache di mana entri yang paling lama tidak diakses akan dihapus pertama kali saat cache penuh, memaksimalkan peluang cache hit untuk data “hangat”.

978. **Design by Contract**
     Pendekatan pengembangan di mana _precondition_, _postcondition_, dan _invariant_ didefinisikan secara eksplisit pada fungsi atau kelas, membantu deteksi pelanggaran asumsi pada runtime atau saat pengujian.

979. **Self-Documenting Code**
     Praktik menulis kode dengan penamaan variabel, fungsi, dan struktur yang jelas sehingga kode itu sendiri menjadi bentuk dokumentasi, meminimalkan kebutuhan komentar berlebihan.

980. **Code Comment Annotations**
     Tag khusus dalam komentar (mis. `// TODO:`, `// FIXME:`, `// NOTE:`) yang memungkinkan tooling editor/CI untuk menyoroti catatan penting dan mempermudah tindak lanjut.

981. **Incident Management**
     Proses terstruktur untuk mendeteksi, merespons, menganalisis, dan menutup insiden (downtime, degradasi performa) di sistem produksi, termasuk _postmortem_ dan _service-level_ evaluasi.

982. **Change Management**
     Kerangka kerja untuk merencanakan, mengevaluasi, dan meninjau perubahan infrastruktur atau aplikasi—meliputi pengajuan RFC, persetujuan, pelaksanaan, dan validasi pasca-implementasi.

983. **Runbook**
     Dokumen operasional yang merinci langkah-langkah prosedural untuk mengelola sistem—deploy, rollback, pemulihan darurat—ditujukan untuk tim SRE/ops agar tanggap saat insiden.

984. **Synthetic Transaction Monitoring**
     Teknik observability di mana agen otomatis menjalankan alur pengguna simulasi (login, pencarian, checkout) secara berkala untuk memverifikasi fungsionalitas end-to-end.

985. **Chaos Monkey**
     Alat dari Netflix (bagian Chaos Engineering) yang secara acak mematikan instance di produksi untuk menguji ketahanan dan melihat apakah sistem dapat pulih otomatis.

986. **Traffic Shaping**
     Teknik mengontrol aliran trafik jaringan—membatasi bandwidth, menentukan prioritas jenis lalu lintas—agar mencegah kemacetan (congestion) dan memastikan kualitas layanan.

987. **Service Level Indicator (SLI)**
     Metrik kuantitatif yang mengukur performa layanan (latency, error rate, throughput) sebagai dasar evaluasi SLO dan SLA.

988. **Service Level Objective (SLO)**
     Target kinerja konkret untuk SLI (mis. 99.9% request latency <200 ms) yang tim operasional berkomitmen untuk dipenuhi.

989. **Service Level Agreement (SLA)**
     Kontrak formal antara penyedia layanan dan pelanggan yang menetapkan SLO, penalty jika tidak tercapai, dan cakupan respons insiden.

990. **Blameless Postmortem**
     Proses dokumentasi insiden tanpa menyalahkan individu, fokus pada analisis akar penyebab dan perbaikan proses untuk mencegah pengulangan.

991. **Traffic Mirroring**
     Menyalin (mirror) trafik produksi ke lingkungan staging atau alat analisis tanpa memengaruhi jalannya produksi, membantu pengujian dan debugging real-time.

992. **Blue/Green Deployment**
     Strategi release dengan dua lingkungan identik (biru dan hijau); satu aktif melayani produksi, yang lain diisi versi baru lalu di-swap bila siap.

993. **Canary Deployment**
     Peluncuran versi baru ke sebagian kecil pengguna (canary) untuk memonitor performa sebelum peluncuran luas.

994. **Rolling Deployment**
     Upgrade aplikasi secara bertahap pada subset instance hingga semua terupdate, memastikan tidak ada downtime.

995. **Dark Launch**
     Peluncuran fitur baru di produksi tanpa mengeksposnya ke pengguna, memungkinkan pengujian internal dan pengumpulan metrik sebelum publikasi.

996. **Grey Release**
     Strategi peluncuran di mana fitur baru diberikan secara bertahap kepada segmen pengguna tertentu — lebih halus daripada canary release, dengan metrik yang dipantau untuk memutuskan kelanjutan roll-out penuh.

997. **Shadow Traffic**
     Teknik operasional di mana trafik produksi disalin (“mirrored”) ke instance atau layanan baru tanpa memengaruhi respons pengguna asli, guna menguji performa dan stabilitas versi mendatang.

998. **Shadow Testing**
     Proses validasi layanan baru dengan menjalankan permintaan nyata di lingkungan isolasi (shadow), memverifikasi hasil tanpa eksposur ke pengguna akhir.

999. **Error Budget**
     Kuota toleransi kegagalan yang diperbolehkan dalam periode tertentu (mis. maksimum 0.1 % permintaan ber-status error) berdasarkan SLO; digunakan untuk menyeimbangkan kecepatan rilis dan keandalan.

1000. **Error Budget Policy**
      Kebijakan formal yang mengatur bagaimana tim menggunakan atau “menghabiskan” error budget — kapan menghentikan rilis fitur baru, kapan fokus pada perbaikan, dan eskalasi jika budget tercapai.

1001. **Swimlane Diagram**
      Diagram alur kerja yang memetakan aktivitas ke “swimlane” vertikal atau horizontal berdasar peran, sistem, atau tim, memudahkan visualisasi tanggung jawab dan interaksi dalam proses.

1002. **Gantt Chart**
      Representasi bar chart dari jadwal proyek, menampilkan tugas sebagai batang dengan tanggal mulai-selesai, dependensi, dan milestone untuk perencanaan dan pelacakan kemajuan.

1003. **PERT Chart**
      Diagram jaringan tugas (Program Evaluation Review Technique) yang menggambarkan urutan, estimasi durasi, dan jalur kritis, membantu memperkirakan waktu penyelesaian proyek dengan ketidakpastian.

1004. **Critical Path**
      Rangkaian tugas terpanjang dalam PERT/CPM yang menentukan durasi minimum proyek; penundaan pada jalur ini akan menunda keseluruhan penyelesaian.

1005. **Fishbone Diagram (Ishikawa Diagram)**
      Alat analisis akar penyebab yang menyusun faktor-faktor potensial (Manusia, Metode, Mesin, Material, Lingkungan, Pengukuran) sebagai “tulang ikan” untuk mengidentifikasi sumber masalah.
1006. **Pure Function**
      Fungsi yang selalu menghasilkan output yang sama untuk input yang sama dan tidak menimbulkan efek samping (side effects), memudahkan pengujian dan reasoning.

1007. **Side Effect**
      Setiap interaksi fungsi atau ekspresi yang memodifikasi state eksternal (I/O, variabel global, database) di luar nilai yang dikembalikan.

1008. **Referential Transparency**
      Properti ekspresi yang dapat digantikan dengan nilai yang dikembalikannya tanpa mengubah perilaku program, karakteristik penting dalam pemrograman fungsional.

1009. **Quine**
      Program yang ketika dijalankan mencetak kode sumbernya sendiri persis, sering digunakan sebagai tantangan teoretis dalam teori bahasa dan rekursi.

1010. **Inversion of Control (IoC)**
      Pola arsitektur di mana alih-alih komponen memanggil dependensi langsung, dependensi “diinjeksikan” dari luar (framework atau container), memisahkan konfigurasi dari penggunaan.

1011. **Dependency Inversion Principle (DIP)**
      Prinsip “D” dalam SOLID yang menyatakan modul tingkat tinggi tidak boleh bergantung pada modul tingkat rendah; keduanya harus bergantung pada abstraksi.

1012. **Service Locator vs Dependency Injection**
      Dua teknik IoC:
      \- _Service Locator_: komponen meminta dependensi dari registry global.
      \- _Dependency Injection_: dependensi disuntikkan melalui konstruktor, setter, atau interface.

1013. **Instrumentation**
      Proses menambahkan probe atau metrik (timing, counters, logs) ke kode untuk memantau performa, penggunaan, dan perilaku aplikasi di runtime.

1014. **Telemetry**
      Pengumpulan data operasional (logs, metrics, traces) secara otomatis dari aplikasi/infra untuk observability, analisis, dan alerting.

1015. **Chaos Engineering**
      Praktik memvalidasi keandalan sistem dengan mengintroduksi gangguan nyata (pod kill, network latency) menurut eksperimen terdefinisi, mengungkap titik lemah.
1016. **Prompt Engineering**
      Seni dan ilmu merancang input (prompts) yang efektif untuk sistem berbasis model bahasa besar (LLM), termasuk teknik framing, few-shot examples, dan instruksi eksplisit agar keluaran sesuai kebutuhan.

1017. **Chain-of-Thought (CoT)**
      Metode mengarahkan LLM untuk menjelaskan langkah-langkah penalarannya secara eksplisit dalam respons, meningkatkan kemampuan model untuk menyelesaikan tugas kompleks melalui alur logis.

1018. **Few-Shot Learning**
      Pendekatan di mana LLM diberikan beberapa contoh (biasanya 1–10) dalam prompt untuk memandu pola keluaran, tanpa melatih ulang model, berguna saat data pelatihan terbatas.

1019. **Zero-Shot Learning**
      Kemampuan model menghasilkan jawaban untuk tugas baru tanpa contoh spesifik dalam prompt, hanya mengandalkan pemahaman lanjutan yang diperoleh selama pre-training.

1020. **Retrieval-Augmented Generation (RAG)**
      Teknik menggabungkan LLM dengan sistem pencarian dokumen: model menarik konteks relevan dari basis data eksternal atau vector store, lalu menghasilkan jawaban yang didukung bukti.

1021. **Embedding**
      Representasi vektor numerik berdimensi tetap untuk teks, gambar, atau entitas lain, digunakan dalam pencarian semantik, klastering, dan pembelajaran lanjutan.

1022. **Vector Database**
      Basis data yang dioptimasi untuk menyimpan dan mencari embedding vektor (mis. via k-NN), memfasilitasi aplikasi RAG, rekomendasi, dan pencarian semantik.

1023. **Attention Head**
      Sub-komponen dalam lapisan self-attention (Transformer) yang memodulasi eksplorasi relasi antar token; model multi-head attention menggabungkan beberapa head untuk menangkap pola berbeda.

1024. **Gradient Checkpointing**
      Teknik mengurangi konsumsi memori saat melatih model besar dengan menyimpan sebagian aktivasi dan menghitung ulang sisanya saat backpropagation, menukar memori dengan komputasi ekstra.

1025. **Mixed Precision Training**
      Pelatihan neural network menggunakan kombinasi presisi (biasanya FP16 untuk sebagian besar bobot dan FP32 untuk akumulasi), mempercepat komputasi di GPU/TPU tanpa kehilangan stabilitas.
1026. **Consistent Hashing**
      Algoritma pembagian beban pada _distributed cache_ atau shard database yang memetakan kunci ke node secara merata, dengan minimalisasi _reshuffling_ ketika node bergabung atau ditinggalkan.

1027. **Rendezvous (Highest Random Weight) Hashing**
      Teknik pemilihan node deterministik untuk suatu kunci dalam sistem terdistribusi, di mana setiap node menghitung skor acak berdasarkan key, dan kunci diarahkan ke node dengan skor tertinggi.

1028. **Quorum Read/Write**
      Strategi pada sistem terdistribusi di mana operasi baca/tulis memerlukan persetujuan mayoritas (quorum) dari replika untuk menjamin konsistensi tertentu sesuai model CAP.

1029. **Stale-While-Revalidate**
      Kebijakan caching HTTP di mana respons cache lama boleh digunakan sementara salinan baru diambil di latar belakang, meminimalkan latensi sambil tetap menyegarkan data.

1030. **Debounce**
      Pola pemrograman _event handler_ yang menunda pelaksanaan fungsi hingga setelah jeda waktu tertentu sejak pemanggilan terakhir, mengurangi frekuensi panggilan pada input yang cepat berubah (scroll, resize).

1031. **Throttle**
      Teknik kontrol frekuensi _event handler_ yang memastikan fungsi hanya dipanggil sekali setiap interval waktu tetap, mencegah beban berlebihan pada event yang bersifat _high-frequency_.

1032. **LRU Cache (Least Recently Used)**
      Kebijakan penggantian cache di mana entri yang paling lama tidak diakses akan dihapus pertama kali saat cache penuh, memaksimalkan peluang cache hit untuk data “hangat”.

1033. **Design by Contract**
      Pendekatan pengembangan di mana _precondition_, _postcondition_, dan _invariant_ didefinisikan secara eksplisit pada fungsi atau kelas, membantu deteksi pelanggaran asumsi pada runtime atau saat pengujian.

1034. **Self-Documenting Code**
      Praktik menulis kode dengan penamaan variabel, fungsi, dan struktur yang jelas sehingga kode itu sendiri menjadi bentuk dokumentasi, meminimalkan kebutuhan komentar berlebihan.

1035. **Code Comment Annotations**
      Tag khusus dalam komentar (mis. `// TODO:`, `// FIXME:`, `// NOTE:`) yang memungkinkan tooling editor/CI untuk menyoroti catatan penting dan mempermudah tindak lanjut.

1036. **Incident Management**
      Proses terstruktur untuk mendeteksi, merespons, menganalisis, dan menutup insiden (downtime, degradasi performa) di sistem produksi, termasuk _postmortem_ dan _service-level_ evaluasi.

1037. **Change Management**
      Kerangka kerja untuk merencanakan, mengevaluasi, dan meninjau perubahan infrastruktur atau aplikasi—meliputi pengajuan RFC, persetujuan, pelaksanaan, dan validasi pasca-implementasi.

1038. **Runbook**
      Dokumen operasional yang merinci langkah-langkah prosedural untuk mengelola sistem—deploy, rollback, pemulihan darurat—ditujukan untuk tim SRE/ops agar tanggap saat insiden.

1039. **Synthetic Transaction Monitoring**
      Teknik observability di mana agen otomatis menjalankan alur pengguna simulasi (login, pencarian, checkout) secara berkala untuk memverifikasi fungsionalitas end-to-end.

1040. **Chaos Monkey**
      Alat dari Netflix (bagian Chaos Engineering) yang secara acak mematikan instance di produksi untuk menguji ketahanan dan melihat apakah sistem dapat pulih otomatis.

1041. **Traffic Shaping**
      Teknik mengontrol aliran trafik jaringan—membatasi bandwidth, menentukan prioritas jenis lalu lintas—agar mencegah kemacetan (congestion) dan memastikan kualitas layanan.

1042. **Service Level Indicator (SLI)**
      Metrik kuantitatif yang mengukur performa layanan (latency, error rate, throughput) sebagai dasar evaluasi SLO dan SLA.

1043. **Service Level Objective (SLO)**
      Target kinerja konkret untuk SLI (mis. 99.9% request latency <200 ms) yang tim operasional berkomitmen untuk dipenuhi.

1044. **Service Level Agreement (SLA)**
      Kontrak formal antara penyedia layanan dan pelanggan yang menetapkan SLO, penalty jika tidak tercapai, dan cakupan respons insiden.

1045. **Blameless Postmortem**
      Proses dokumentasi insiden tanpa menyalahkan individu, fokus pada analisis akar penyebab dan perbaikan proses untuk mencegah pengulangan.

1046. **Traffic Mirroring**
      Menyalin (mirror) trafik produksi ke lingkungan staging atau alat analisis tanpa memengaruhi jalannya produksi, membantu pengujian dan debugging real-time.

1047. **Blue/Green Deployment**
      Strategi release dengan dua lingkungan identik (biru dan hijau); satu aktif melayani produksi, yang lain diisi versi baru lalu di-swap bila siap.

1048. **Canary Deployment**
      Peluncuran versi baru ke sebagian kecil pengguna (canary) untuk memonitor performa sebelum peluncuran luas.

1049. **Rolling Deployment**
      Upgrade aplikasi secara bertahap pada subset instance hingga semua terupdate, memastikan tidak ada downtime.

1050. **Dark Launch**
      Peluncuran fitur baru di produksi tanpa mengeksposnya ke pengguna, memungkinkan pengujian internal dan pengumpulan metrik sebelum publikasi.

1051. **Grey Release**
      Strategi peluncuran di mana fitur baru diberikan secara bertahap kepada segmen pengguna tertentu — lebih halus daripada canary release, dengan metrik yang dipantau untuk memutuskan kelanjutan roll-out penuh.

1052. **Shadow Traffic**
      Teknik operasional di mana trafik produksi disalin (“mirrored”) ke instance atau layanan baru tanpa memengaruhi respons pengguna asli, guna menguji performa dan stabilitas versi mendatang.

1053. **Shadow Testing**
      Proses validasi layanan baru dengan menjalankan permintaan nyata di lingkungan isolasi (shadow), memverifikasi hasil tanpa eksposur ke pengguna akhir.

1054. **Error Budget**
      Kuota toleransi kegagalan yang diperbolehkan dalam periode tertentu (mis. maksimum 0.1 % permintaan ber-status error) berdasarkan SLO; digunakan untuk menyeimbangkan kecepatan rilis dan keandalan.

1055. **Error Budget Policy**
      Kebijakan formal yang mengatur bagaimana tim menggunakan atau “menghabiskan” error budget — kapan menghentikan rilis fitur baru, kapan fokus pada perbaikan, dan eskalasi jika budget tercapai.

1056. **Swimlane Diagram**
      Diagram alur kerja yang memetakan aktivitas ke “swimlane” vertikal atau horizontal berdasar peran, sistem, atau tim, memudahkan visualisasi tanggung jawab dan interaksi dalam proses.

1057. **Gantt Chart**
      Representasi bar chart dari jadwal proyek, menampilkan tugas sebagai batang dengan tanggal mulai-selesai, dependensi, dan milestone untuk perencanaan dan pelacakan kemajuan.

1058. **PERT Chart**
      Diagram jaringan tugas (Program Evaluation Review Technique) yang menggambarkan urutan, estimasi durasi, dan jalur kritis, membantu memperkirakan waktu penyelesaian proyek dengan ketidakpastian.

1059. **Critical Path**
      Rangkaian tugas terpanjang dalam PERT/CPM yang menentukan durasi minimum proyek; penundaan pada jalur ini akan menunda keseluruhan penyelesaian.

1060. **Fishbone Diagram (Ishikawa Diagram)**
      Alat analisis akar penyebab yang menyusun faktor-faktor potensial (Manusia, Metode, Mesin, Material, Lingkungan, Pengukuran) sebagai “tulang ikan” untuk mengidentifikasi sumber masalah.
1061. **Pure Function**
      Fungsi yang selalu menghasilkan output yang sama untuk input yang sama dan tidak menimbulkan efek samping (side effects), memudahkan pengujian dan reasoning.

1062. **Side Effect**
      Setiap interaksi fungsi atau ekspresi yang memodifikasi state eksternal (I/O, variabel global, database) di luar nilai yang dikembalikan.

1063. **Referential Transparency**
      Properti ekspresi yang dapat digantikan dengan nilai yang dikembalikannya tanpa mengubah perilaku program, karakteristik penting dalam pemrograman fungsional.

1064. **Quine**
      Program yang ketika dijalankan mencetak kode sumbernya sendiri persis, sering digunakan sebagai tantangan teoretis dalam teori bahasa dan rekursi.

1065. **Inversion of Control (IoC)**
      Pola arsitektur di mana alih-alih komponen memanggil dependensi langsung, dependensi “diinjeksikan” dari luar (framework atau container), memisahkan konfigurasi dari penggunaan.

1066. **Dependency Inversion Principle (DIP)**
      Prinsip “D” dalam SOLID yang menyatakan modul tingkat tinggi tidak boleh bergantung pada modul tingkat rendah; keduanya harus bergantung pada abstraksi.

1067. **Service Locator vs Dependency Injection**
      Dua teknik IoC:
      \- _Service Locator_: komponen meminta dependensi dari registry global.
      \- _Dependency Injection_: dependensi disuntikkan melalui konstruktor, setter, atau interface.

1068. **Instrumentation**
      Proses menambahkan probe atau metrik (timing, counters, logs) ke kode untuk memantau performa, penggunaan, dan perilaku aplikasi di runtime.

1069. **Telemetry**
      Pengumpulan data operasional (logs, metrics, traces) secara otomatis dari aplikasi/infra untuk observability, analisis, dan alerting.

1070. **Chaos Engineering**
      Praktik memvalidasi keandalan sistem dengan mengintroduksi gangguan nyata (pod kill, network latency) menurut eksperimen terdefinisi, mengungkap titik lemah.
1071. **Prompt Engineering**
      Seni dan ilmu merancang input (prompts) yang efektif untuk sistem berbasis model bahasa besar (LLM), termasuk teknik framing, few-shot examples, dan instruksi eksplisit agar keluaran sesuai kebutuhan.

1072. **Chain-of-Thought (CoT)**
      Metode mengarahkan LLM untuk menjelaskan langkah-langkah penalarannya secara eksplisit dalam respons, meningkatkan kemampuan model untuk menyelesaikan tugas kompleks melalui alur logis.

1073. **Few-Shot Learning**
      Pendekatan di mana LLM diberikan beberapa contoh (biasanya 1–10) dalam prompt untuk memandu pola keluaran, tanpa melatih ulang model, berguna saat data pelatihan terbatas.

1074. **Zero-Shot Learning**
      Kemampuan model menghasilkan jawaban untuk tugas baru tanpa contoh spesifik dalam prompt, hanya mengandalkan pemahaman lanjutan yang diperoleh selama pre-training.

1075. **Retrieval-Augmented Generation (RAG)**
      Teknik menggabungkan LLM dengan sistem pencarian dokumen: model menarik konteks relevan dari basis data eksternal atau vector store, lalu menghasilkan jawaban yang didukung bukti.

1076. **Embedding**
      Representasi vektor numerik berdimensi tetap untuk teks, gambar, atau entitas lain, digunakan dalam pencarian semantik, klastering, dan pembelajaran lanjutan.

1077. **Vector Database**
      Basis data yang dioptimasi untuk menyimpan dan mencari embedding vektor (mis. via k-NN), memfasilitasi aplikasi RAG, rekomendasi, dan pencarian semantik.

1078. **Attention Head**
      Sub-komponen dalam lapisan self-attention (Transformer) yang memodulasi eksplorasi relasi antar token; model multi-head attention menggabungkan beberapa head untuk menangkap pola berbeda.

1079. **Gradient Checkpointing**
      Teknik mengurangi konsumsi memori saat melatih model besar dengan menyimpan sebagian aktivasi dan menghitung ulang sisanya saat backpropagation, menukar memori dengan komputasi ekstra.

1080. **Mixed Precision Training**
      Pelatihan neural network menggunakan kombinasi presisi (biasanya FP16 untuk sebagian besar bobot dan FP32 untuk akumulasi), mempercepat komputasi di GPU/TPU tanpa kehilangan stabilitas.

1081. **Model Pruning**
      Pengurangan ukuran model dengan menghapus bobot atau neuron yang kontribusinya rendah, menghasilkan versi lebih ringan dan cepat untuk inferensi.

1082. **Quantization**
      Transformasi bobot dan aktivasi dari presisi tinggi (FP32) ke format lebih ringkas (int8, int4), mengurangi jejak memori dan latensi inferensi dengan trade-off kecil pada akurasi.

1083. **Knowledge Distillation**
      Proses melatih model kecil (“student”) untuk meniru keluaran model besar (“teacher”), menghasilkan model ringan yang mempertahankan performa mendekati aslinya.

1084. **Federated Learning**
      Protokol pelatihan terdistribusi di mana data tetap berada di perangkat klien, model diperbarui secara lokal, dan sekumpulan gradien digabung di server pusat tanpa mengekspos data mentah.

1085. **Differential Privacy**
      Metode matematika untuk menambahkan noise terukur pada data atau gradien selama pelatihan, menjaga privasi individu dalam dataset sambil mempertahankan utilitas model.
1086. **Flaky Test**
      Ujian otomatis (unit, integrasi, atau end-to-end) yang kadang lulus dan kadang gagal tanpa perubahan kode atau lingkungan yang konsisten, menyulitkan kepercayaan pada hasil dan perlu diidentifikasi serta diperbaiki (mis. dengan stabilisasi setup, penundaan eksplisit, atau mock yang lebih deterministik).

1087. **Monkey Testing**
      Metode pengujian di mana alat atau tester mengirimkan input acak atau tidak terstruktur ke aplikasi untuk menemukan bug tak terduga atau crash, berguna melengkapi test case terencana dengan eksplorasi _ad hoc_.

1088. **Pseudocode**
      Deskripsi algoritma atau logika program dalam format semi-formal—campuran bahasa alami dan konstruksi kode—tujuannya menjelaskan alur dan struktur tanpa terikat pada sintaks bahasa pemrograman tertentu.

1089. **Identifier Naming Conventions**
      Gaya penamaan variabel, fungsi, kelas, dan modul untuk meningkatkan keterbacaan dan konsistensi:
      \- _snake_case_: semua huruf kecil dengan underscore (`my_variable`).
      \- _camelCase_: huruf pertama kecil, kapital setiap kata berikutnya (`myVariable`).
      \- _PascalCase_: tiap kata diawali huruf kapital (`MyVariable`).
      \- _kebab-case_: semua huruf kecil dengan tanda hubung (`my-variable`).

1090. **YAML Anchors & Aliases**
      Mekanisme reuse di file YAML di mana blok data dapat diberi label (`&anchor`) dan kemudian digunakan kembali (`*alias`) dalam struktur lain, meminimalkan duplikasi konfigurasi dan memudahkan pemeliharaan
1091. **Idempotency Key**
      Nilai unik yang disertakan dalam permintaan API untuk menjamin operasi bersifat idempoten—jika klien mengirim ulang permintaan dengan kunci yang sama, server akan mengembalikan respons yang sama tanpa melakukan tindakan ganda.

1092. **Schema Migration**
      Proses terorganisir untuk memperbarui struktur basis data (tambah/hapus kolom, ubah tipe data, indeks) menggunakan skrip terurut (migration scripts) yang dapat diterapkan dan di-_rollback_ secara konsisten.

1093. **Split Testing (Feature A/B Test)**
      Variasi dari A/B testing yang lebih luas, di mana beberapa varian (A, B, C…) diuji secara bersamaan pada segmen pengguna berbeda untuk mengevaluasi metrik konversi atau keterlibatan.

1094. **AIOps (Artificial Intelligence for IT Operations)**
      Pendekatan yang menggabungkan big data, machine learning, dan otomasi untuk menganalisis data operasional—logs, metrics, traces—secara real-time, mendeteksi anomali, dan merespon insiden lebih cepat.

1095. **Toil (SRE Toil)**
      Pekerjaan operasional berulang dan manual yang tidak memberikan nilai langsung (mis. merestart service, pengecekan rutin), yang SRE berusaha minimalisir melalui automasi untuk fokus pada peningkatan sistem.

1096. **Technical Vision Document**
      Dokumen strategis yang merinci tujuan teknis jangka panjang, arsitektur target, keputusan teknologi kunci, dan roadmap evolusi sistem untuk memandu tim dalam pengambilan keputusan skala besar.

1097. **System Requirements Specification (SRS)**
      Dokumen formal yang menguraikan kebutuhan fungsional dan non-fungsional sistem—fitur, performa, keamanan, batasan—sebagai dasar kontrak pengembangan antara pengembang dan pemangku kepentingan.

1098. **Use Case Diagram**
      Diagram UML yang memetakan aktor (pengguna atau sistem eksternal) dan use case (fungsi sistem) sebagai oval, menggambarkan interaksi tinggi-level untuk analisis kebutuhan.

1099. **Sequence Diagram**
      Diagram UML yang menunjukkan alur pesan antar objek atau komponen dalam suatu skenario tertentu—menampilkan lifeline vertikal dan panah panggilan metode—untuk memvisualisasikan urutan eksekusi.

1100. **Context Diagram**
      Diagram tingkatan tertinggi (level-0 DFD) yang menempatkan sistem atau aplikasi di tengah dan menggambarkan hubungan dengan entitas eksternal (aktor, sistem lain) untuk memahami batasan ruang lingkup.
1101. **YAML Anchors & Aliases**
      Mekanisme reuse dan DRY (“Don’t Repeat Yourself”) di file konfigurasi YAML, terdiri dari dua konsep utama:

1102. **Anchor (`&`)**
      Menandai blok node (scalar, sequence, atau mapping) agar dapat dirujuk kembali. Syntax:

      ```yaml
      defaults: &defaults
        timeout: 30
        retries: 3
      ```

      Di sini, seluruh mapping `{ timeout: 30, retries: 3 }` diberi label `defaults`.

1103. **Alias (`*`)**
      Menyisipkan ulang isi node yang telah di-anchor tanpa menyalin teksnya secara manual. Syntax:

      ```yaml
      serviceA:
        <<: *defaults
        endpoint: /a

      serviceB:
        <<: *defaults
        endpoint: /b
      ```

      Operator `<<:` adalah _merge key_ standar YAML untuk menggabungkan mapping alias ke dalam mapping target. Hasilnya:

      ```yaml
      serviceA:
        timeout: 30
        retries: 3
        endpoint: /a

      serviceB:
        timeout: 30
        retries: 3
        endpoint: /b
      ```

**Kegunaan dan Manfaat**

- **Konsistensi**: menghindari duplikasi nilai default di banyak tempat.
- **Kemudahan Pemeliharaan**: perubahan pada _anchor_ otomatis ter-reflect di semua _alias_.
- **Bersih dan Ringkas**: menjadikan file konfigurasi lebih mudah dibaca.

**Perhatian**

- Editor YAML tertentu (atau parser versi lama) mungkin belum mendukung _merge key_ (`<<:`). Pastikan tool yang Anda gunakan patuh terhadap spesifikasi YAML 1.1/1.2.
- Hindari _alias_ bersarang berlebihan—terlalu banyak level referensi bisa membuat debugging konfigurasi menjadi sulit.
- _Alias_ hanya menyalin nilai, bukan _reference_ dinamis; perubahan _alias_ setelah parsing tidak memengaruhi _anchor_.

Dengan memahami dan menerapkan _anchors_ & _aliases_, Anda dapat merancang konfigurasi YAML yang modular, terstruktur, dan mudah diubah sesuai kebutuhan proyek.

1101. **Architecture Decision Record (ADR)**
        Dokumen ringkas yang mencatat keputusan arsitektural penting—latar belakang, opsi yang dipertimbangkan, alasan pilihan, dan konsekuensi—sebagai referensi historis bagi tim pengembang.

1102. **Static Application Security Testing (SAST)**
        Analisis keamanan kode sumber tanpa menjalankan aplikasi, menggunakan scanner statis untuk mendeteksi pola kerentanan (injection, buffer overflow) sebelum build.

1103. **Dynamic Application Security Testing (DAST)**
        Pengujian keamanan pada aplikasi berjalan (black-box), mengirimkan permintaan ke endpoint untuk menemukan celah runtime (XSS, CSRF) tanpa akses ke kode sumber.

1104. **Interactive Application Security Testing (IAST)**
        Kombinasi SAST dan DAST di mana agen berinstrumentasi mengamati alur eksekusi selama pengujian fungsional untuk mendeteksi kerentanan dengan konteks runtime.

1105. **Software Composition Analysis (SCA)**
        Pemindaian dependensi open-source suatu proyek untuk mengidentifikasi lisensi, versi, dan kerentanan keamanan pada pustaka pihak ketiga.

1106. **Branch by Abstraction**
        Pola pengembangan di mana fitur baru diintegrasikan ke dalam branch utama dengan menyembunyikan implementasi lama dan baru di balik abstraksi, kemudian beralih secara bertahap.

1107. **Micro Frontends**
        Arsitektur front-end di mana aplikasi web besar dibagi menjadi beberapa “mini-aplikasi” independen—masing-masing dapat dipilih teknologinya sendiri dan dideploy secara terpisah.

1108. **Headless CMS**
        Sistem manajemen konten di mana backend (penyimpanan, API) terpisah dari frontend; konten disajikan lewat API ke berbagai klien (web, mobile, IoT).

1109. **Backend-for-Frontend (BFF)**
        Lapisan server yang dirancang khusus untuk satu jenis klien (web, mobile), menyederhanakan agregasi data dan autentikasi dibandingkan satu API tunggal untuk semua klien.

1110. **Progressive Delivery**
        Evolusi dari Continuous Delivery dengan feature flags, canary, A/B testing, dan pengontrolan rollout untuk meminimalkan risiko rilis dan memaksimalkan umpan balik.

1111. **Data Virtualization**
        Lapisan abstraksi data yang memungkinkan query ke berbagai sumber (relasional, NoSQL, file) seolah-olah satu database virtual, tanpa menyalin data fisik.

1112. **Data Fabric**
        Arsitektur dan set layanan terintegrasi yang menyediakan akses, integrasi, dan governance data secara konsisten di seluruh data center dan cloud.

1113. **Machine Learning Operations (MLOps)**
        Praktik DevOps yang diperluas untuk model ML, mencakup retraining otomatis, deployment model, monitoring performa prediktif, dan manajemen versi data serta model.

1114. **DataOps**
        Metodologi pengembangan dan integrasi data yang meniru prinsip DevOps—kolaborasi data engineer, data scientist, dan ops untuk pipeline data cepat, repeatable, dan berkualitas.

1115. **Observability Platform**
        Suite terpadu untuk mengumpulkan, menyimpan, dan menganalisis logs, metrics, dan traces—sering dilengkapi AI/ML untuk deteksi anomali otomatis.

1116. **Headless Testing**
        Pengujian UI dan end-to-end menggunakan browser tanpa tampilan grafis (headless), mempermudah otomasi dalam CI pipeline tanpa ketergantungan pada display server.

1117. **Test Impact Analysis**
        Proses menentukan subset test suite yang terpengaruh oleh perubahan kode terbaru, sehingga hanya test relevan yang dijalankan untuk mempercepat feedback.

1118. **Dark Launching**
        Men-deploy kode baru di produksi tetapi menyembunyikan fitur di balik flag, memungkinkan monitoring performance dan integrasi tanpa eksposur ke pengguna.

1119. **Blueprint Repository**
        Repositori terpusat yang menyimpan template, modul, dan best practice (Terraform, Helm, Ansible) untuk meng-standarisasi infrastruktur dan arsitektur aplikasi.

1120. **Chaos Engineering Platform**
        Alat atau layanan terintegrasi (Chaos Monkey, Gremlin, Litmus) untuk mengatur, menjalankan, dan memantau eksperimen chaos secara otomatis, termasuk analisis hasil dan laporan risiko.

**1121. Immutable Object**
Objek yang nilainya tidak dapat diubah setelah dibuat. Biasanya digunakan untuk menjaga konsistensi, thread safety, dan mencegah efek samping. Contoh umum: `String` di Java dan Dart.

**1122. Fluent Interface**
Pola desain yang memungkinkan chaining method dengan mengembalikan objek yang sama, menciptakan sintaks seperti kalimat natural. Contoh: `builder.setName("X").setAge(30).build();`

**1123. Command Bus**
Komponen arsitektur yang bertugas menangani perintah (command) yang dikirim oleh client. Ia mendistribusikan command ke handler-nya masing-masing. Umum dalam pattern CQRS.

**1124. Spike Solution**
Eksperimen kode cepat untuk mengevaluasi pendekatan atau teknologi sebelum diimplementasikan secara penuh. Tujuannya eksplorasi, bukan kode produksi.

**1125. Tuple**
Struktur data yang menyimpan sejumlah nilai tetap dalam satu unit, biasanya heterogen dan bersifat immutable. Banyak ditemukan di bahasa fungsional dan Python.

**1126. Monkey Patching**
Praktik mengubah atau menimpa fungsi/method bawaan pada runtime, biasanya untuk testing atau modifikasi perilaku library pihak ketiga. Berisiko menimbulkan bug tersembunyi.

**1127. Fan-out**
Pola distribusi data atau pekerjaan dari satu komponen ke banyak komponen atau layanan lainnya secara paralel. Contoh umum: pemrosesan paralel dalam sistem event-driven.

**1128. Throttling**
Pembatasan jumlah permintaan dalam jangka waktu tertentu untuk menghindari overload sistem. Berbeda dari rate limiting karena dapat memperlambat, bukan memblokir.

**1129. Transpiler**
Compiler yang mengubah kode sumber dari satu bahasa ke bahasa lain dengan level abstraksi serupa, misalnya dari TypeScript ke JavaScript, atau SASS ke CSS.

**1130. Serialization**
Proses mengubah objek menjadi format yang bisa disimpan atau ditransmisikan (seperti JSON, XML, atau binary), lalu di-deserialize kembali menjadi objek.

**1131. Temporal Coupling**
Ketergantungan antar komponen atau method berdasarkan urutan waktu eksekusi. Biasanya dianggap buruk jika urutannya tidak jelas dan tidak terdokumentasi.

**1132. Version Pinning**
Praktik menentukan versi spesifik dari dependensi untuk mencegah update otomatis yang bisa merusak kompatibilitas atau kestabilan.

**1133. Watcher (File Watcher)**
Proses atau tool yang memonitor perubahan file dan secara otomatis menjalankan aksi (rebuild, reload, test) saat terjadi perubahan.

**1134. "Fail Open" dan "Fail Closed"**
Strategi sistem saat terjadi kegagalan:

- **Fail Open**: sistem membiarkan akses atau proses berlanjut (berisiko).
- **Fail Closed**: sistem memblokir akses untuk keamanan.

**1135. Shared Nothing Architecture**
Arsitektur di mana setiap node tidak berbagi state atau sumber daya fisik, meningkatkan skalabilitas dan toleransi kesalahan.

**1136. Heatmap**
Visualisasi data dalam bentuk warna untuk menunjukkan intensitas atau frekuensi, misalnya penggunaan fungsi, request API, atau klik pengguna.

**1137. Request Coalescing**
Teknik optimasi di mana beberapa request serupa yang terjadi hampir bersamaan digabungkan menjadi satu request ke backend untuk efisiensi.

**1138. Cold Start**
Kondisi awal saat sistem belum siap memproses permintaan, misalnya saat fungsi serverless pertama kali dijalankan dan butuh inisialisasi.

**1139. Trunk-based Development**
Praktik pengembangan di mana semua developer bekerja pada satu branch utama (`main` atau `trunk`), dan fitur diintegrasikan secara cepat dan sering.

**1140. Deadlock**
Situasi ketika dua atau lebih proses saling menunggu satu sama lain untuk sumber daya yang sedang dikunci, mengakibatkan kebuntuan sistem.

**1141. Dependency Injection (DI)**
Pola desain di mana objek tidak membuat dependensinya sendiri, tetapi menerima dari luar. Hal ini meningkatkan fleksibilitas dan testability. Banyak digunakan di framework modern seperti Angular dan Spring.

**1142. Inversion of Control (IoC)**
Prinsip desain di mana kontrol alur program dipindahkan dari komponen individu ke framework atau kontainer. Dependency Injection adalah salah satu implementasinya.

**1143. Object Pooling**
Teknik optimasi di mana sejumlah objek dibuat sebelumnya dan digunakan kembali, bukan dibuat dan dihancurkan berulang kali. Berguna untuk objek berat seperti koneksi database.

**1144. Circuit Breaker**
Pola desain pada sistem terdistribusi untuk mencegah pemanggilan berulang ke layanan yang gagal. Jika error terus berulang, sirkuit "terputus" sementara.

**1145. Bloom Filter**
Struktur data probabilistik untuk mengecek apakah suatu elemen mungkin ada dalam sekumpulan data. Cepat dan hemat memori, tapi bisa menghasilkan false positive.

**1146. Fork-Join**
Model paralelisme di mana task di-_fork_ (dipisah menjadi sub-task), lalu hasilnya digabung (_join_). Umum dalam paralel computing dan framework seperti Java Fork/Join Framework.

**1147. Snapshot Testing**
Teknik pengujian di mana output program disimpan sebagai snapshot, dan diuji dengan cara membandingkan output baru dengan snapshot lama.

**1148. REPL (Read-Eval-Print Loop)**
Lingkungan interaktif untuk menjalankan baris perintah satu per satu. Biasa ditemukan di bahasa scripting seperti Python, Node.js, Dart, dsb.

**1149. Rate Limiting**
Teknik untuk membatasi jumlah permintaan dalam periode tertentu agar sistem tidak kelebihan beban. Biasa diterapkan di API atau firewall.

**1150. Thread-safe**
Deskripsi untuk fungsi atau objek yang dapat digunakan secara bersamaan oleh banyak thread tanpa menyebabkan error atau race condition.

**1151. Proxy Object**
Objek yang bertindak sebagai perantara atau pengganti objek lain. Bisa digunakan untuk lazy-loading, logging, access control, dan sebagainya.

**1152. Lazy Evaluation**
Strategi di mana ekspresi tidak dihitung sampai benar-benar dibutuhkan. Berguna untuk efisiensi dan menghindari perhitungan yang tidak perlu.

**1153. Mutex (Mutual Exclusion)**
Objek sinkronisasi yang digunakan untuk menghindari akses bersamaan ke resource bersama, memastikan hanya satu thread yang aktif pada satu waktu.

**1154. Sentinel Value**
Nilai khusus yang menandakan akhir data, error, atau kondisi tertentu. Contoh: -1 untuk indeks tidak ditemukan.

**1155. Hook**
Fungsi callback atau titik ekstensi yang disediakan sistem atau framework agar pengguna bisa menyisipkan kode sendiri. Contoh: `useEffect` di React, atau lifecycle hooks di Flutter.

**1156. Heisenbug**
Bug misterius yang menghilang atau berubah perilakunya saat proses debugging dilakukan. Nama ini berasal dari prinsip ketidakpastian Heisenberg.

**1157. Phantom Read**
Jenis inkonsistensi data dalam database ketika transaksi membaca data yang berubah oleh transaksi lain setelah pembacaan pertama tapi sebelum selesai.

**1158. Soft Delete**
Strategi menghapus data dengan menandai sebagai "terhapus" (misalnya dengan flag), bukan benar-benar menghapusnya dari database. Memungkinkan restore.

**1159. Sidecar Pattern**
Pola arsitektur di mana komponen tambahan (sidecar) dipasang bersama layanan utama untuk menambahkan fitur seperti logging, proxy, observability.

**1160. Temporal Table**
Tabel dalam database yang menyimpan histori perubahan data dari waktu ke waktu. Berguna untuk audit trail, rollback, atau analisis histori.

**1161. Command Bus**
Pola arsitektur di mana perintah (_command_) dikirim melalui saluran tunggal (_bus_) untuk diproses oleh handler tertentu. Umum di aplikasi yang menerapkan CQRS.

**1162. Event Sourcing**
Pola penyimpanan status sistem dengan cara mencatat semua event yang terjadi, bukan hanya menyimpan state akhir. Cocok untuk audit trail dan rollback.

**1163. Immutable Object**
Objek yang nilainya tidak dapat diubah setelah dibuat. Bermanfaat untuk menghindari efek samping dan mempermudah reasoning dalam kode.

**1164. Visitor Pattern**
Pola desain OOP yang memisahkan operasi dari objek yang dikunjunginya. Memungkinkan penambahan operasi tanpa mengubah struktur objek.

**1165. Thread Pool**
Kumpulan thread yang sudah dibuat sebelumnya dan digunakan kembali untuk menjalankan task secara paralel. Meningkatkan efisiensi pemrosesan.

**1166. Shard / Sharding**
Strategi untuk membagi data besar ke dalam beberapa bagian (shard) agar bisa disimpan dan diproses secara paralel di berbagai server.

**1167. Proxy Server**
Server perantara antara klien dan server tujuan. Bisa digunakan untuk caching, filter, atau menyembunyikan identitas klien.

**1168. Bytecode**
Representasi perantara antara source code dan machine code. Bytecode biasanya dijalankan oleh VM (Virtual Machine), seperti Java Bytecode.

**1169. Data Contract**
Kesepakatan eksplisit antara dua sistem tentang struktur dan format data yang dipertukarkan. Penting untuk interoperabilitas API.

**1170. Code Smell**
Tanda dalam kode yang menunjukkan kemungkinan masalah desain atau implementasi. Tidak selalu bug, tapi indikasi bahwa refactor dibutuhkan.

**1171. Cohesion**
Ukuran seberapa erat fungsi-fungsi dalam satu modul saling berkaitan. Semakin tinggi cohesion, semakin baik desain modularitasnya.

**1172. Coupling**
Ukuran seberapa bergantung satu komponen terhadap komponen lainnya. Tujuan desain perangkat lunak adalah menciptakan low coupling dan high cohesion.

**1173. Monoid**
Struktur matematika dengan satu operasi biner asosiatif dan elemen identitas. Konsep ini sering digunakan dalam pemrograman fungsional.

**1174. Polyfill**
Potongan kode yang menyediakan fitur baru pada lingkungan lama yang belum mendukung fitur tersebut. Umum dalam pengembangan web.

**1175. Linter**
Alat yang menganalisis kode sumber untuk mencari kesalahan, inkonsistensi, atau pelanggaran gaya penulisan.

**1176. Semantic Versioning (SemVer)**
Standar penomoran versi perangkat lunak dalam format MAJOR.MINOR.PATCH. Membantu dalam pengelolaan dependensi dan kompatibilitas.

**1177. Regression Testing**
Jenis pengujian untuk memastikan bahwa fitur lama tetap berjalan setelah penambahan atau perubahan kode baru.

**1178. Stack Unwinding**
Proses membalik tumpukan eksekusi saat terjadi exception, untuk menjalankan destructor atau handler yang tepat di sepanjang stack.

**1179. Watcher**
Komponen yang memantau perubahan pada file, variabel, atau struktur data, dan memicu aksi saat perubahan terjadi. Umum di framework reaktif.

**1180. State Machine**
Model komputasi yang merepresentasikan status sistem sebagai serangkaian state dan transisi. Berguna dalam pengendalian logika kompleks.

**1181. Memory Leak**
Kondisi di mana alokasi memori tidak dibebaskan setelah selesai digunakan, menyebabkan konsumsi memori meningkat seiring waktu.

**1182. Thunk**
Fungsi pembungkus (wrapper) yang menunda evaluasi ekspresi. Umum digunakan dalam pemrograman fungsional dan dalam implementasi Redux middleware.

**1183. Debouncing**
Teknik untuk menunda eksekusi fungsi sampai setelah jeda waktu tertentu sejak pemanggilan terakhir. Berguna untuk optimasi event handler.

**1184. Polling**
Metode di mana klien secara berkala mengecek server untuk mengetahui apakah ada data baru. Berlawanan dengan push atau long polling.

**1185. Monadic Binding**
Teknik dalam pemrograman fungsional di mana fungsi digunakan untuk menggabungkan operasi dalam konteks monad (seperti `Option`, `Future`, `IO`).

**1186. Race Condition**
Situasi di mana hasil program tergantung pada urutan eksekusi yang tidak bisa diprediksi, biasanya karena akses bersamaan ke resource bersama.

**1187. Shadowing**
Praktik mendeklarasikan variabel dengan nama yang sama di dalam cakupan baru, sehingga menutupi (shadow) variabel dari cakupan luar.

**1188. Idempotent**
Properti dari fungsi atau operasi yang memberikan hasil yang sama tidak peduli seberapa sering dipanggil dengan input yang sama.

**1189. Zero-Based Indexing**
Konvensi penomoran elemen dalam array atau koleksi dimulai dari indeks 0, bukan 1. Digunakan di banyak bahasa pemrograman modern.

**1190. Greedy Algorithm**
Algoritma yang membuat pilihan lokal optimal pada setiap langkah dengan harapan mendapatkan solusi global optimal.

**1191. Trampoline Function**
Teknik untuk menghindari stack overflow dengan cara memanggil fungsi rekursif secara iteratif melalui pembungkus yang kembali fungsi baru.

**1192. Generational Garbage Collection**
Strategi pengumpulan sampah (GC) di mana objek dikelompokkan berdasarkan usia, karena objek muda biasanya lebih cepat menjadi tidak terpakai.

**1193. Symbol Table**
Struktur data dalam compiler yang menyimpan informasi tentang variabel, fungsi, dan elemen lain yang terdefinisi dalam program.

**1194. Type Erasure**
Proses penghapusan informasi tipe generik saat kompilasi, umum dalam Java generics, di mana informasi tipe tidak tersedia saat runtime.

**1195. Literal**
Nilai tetap yang ditulis secara langsung di kode program, seperti `42`, `"halo"` atau `true`.

**1196. Proxy Pattern**
Pola desain OOP di mana objek perantara mengontrol akses ke objek lain, sering digunakan untuk lazy-loading, keamanan, atau logging.

**1197. Fluent Interface**
Gaya penulisan API di mana metode dikembalikan sebagai objek itu sendiri, memungkinkan pemanggilan metode secara berantai (method chaining).

**1198. Deadlock**
Kondisi dalam sistem paralel ketika dua atau lebih thread saling menunggu sumber daya yang sedang dikunci oleh thread lain, sehingga tidak ada yang bisa melanjutkan eksekusi.

**1199. Namespace Pollution**
Masalah yang muncul ketika terlalu banyak entitas dideklarasikan dalam satu namespace/global scope, meningkatkan kemungkinan konflik nama.

**1200. Watchdog Timer**
Timer sistem yang mendeteksi dan mengatasi program yang hang atau tidak merespons dengan melakukan restart atau tindakan korektif lainnya.

---

# Coding

# Kamus Sebagian Istilah Dalam Bahasa Pemrograman

## A. Istilah Umum Pemrograman

1. **Algoritma**: Serangkaian langkah atau instruksi yang dirancang untuk menyelesaikan tugas tertentu.

2. **Bahasa Pemrograman**: Bahasa formal yang digunakan untuk menulis instruksi yang dapat dieksekusi oleh komputer.

3. **Variabel**: Tempat penyimpanan data dalam program yang dapat berubah nilainya.

4. **Fungsi**: Blok kode yang melakukan tugas tertentu dan dapat dipanggil berulang kali.

5. **Loop**: Struktur kontrol yang mengulang serangkaian instruksi.

6. **Kondisional**: Pernyataan yang memungkinkan program mengambil keputusan berdasarkan kondisi tertentu.

7. **Array**: Struktur data yang menyimpan kumpulan elemen dengan tipe data yang sama.

8. **Object**: Instansi dari sebuah class yang memiliki properti dan metode.

9. **Class**: Blueprint atau template untuk membuat objek dalam pemrograman berorientasi objek.

10. **Debugging**: Proses menemukan dan memperbaiki kesalahan (bug) dalam kode.

## B. Peran dan Spesialisasi dalam Pemrograman

1. **Front-end Developer**: Pengembang yang fokus pada bagian aplikasi yang berinteraksi langsung dengan pengguna.

2. **Back-end Developer**: Pengembang yang bekerja pada sisi server dan logika bisnis aplikasi.

3. **Full-stack Developer**: Pengembang yang memiliki kemampuan baik di front-end maupun back-end.

4. **DevOps Engineer**: Spesialis yang menggabungkan pengembangan software dan operasi IT.

5. **Data Scientist**: Ahli yang menganalisis dan menginterpretasikan data kompleks.

6. **Machine Learning Engineer**: Spesialis yang mengembangkan sistem yang dapat belajar dan meningkat dari pengalaman.

7. **UI/UX Designer**: Desainer yang fokus pada pengalaman pengguna dan antarmuka aplikasi.

## C. Teknologi dan Framework

1. **React**: Library JavaScript untuk membangun antarmuka pengguna.

2. **Angular**: Framework untuk membangun aplikasi web dinamis.

3. **Vue.js**: Framework JavaScript progresif untuk membangun UI.

4. **Node.js**: Runtime JavaScript yang memungkinkan eksekusi JavaScript di sisi server.

5. **Django**: Framework web Python tingkat tinggi.

6. **Flask**: Microframework web Python.

7. **Spring**: Framework aplikasi untuk platform Java.

8. **Ruby on Rails**: Framework aplikasi web yang menggunakan bahasa Ruby.

9. **ASP.NET**: Framework untuk membangun aplikasi web dengan C#.

10. **Laravel**: Framework PHP untuk pengembangan web.

## D. Database dan Penyimpanan Data

1. **SQL**: Structured Query Language, bahasa untuk mengelola database relasional.

2. **MySQL**: Sistem manajemen database relasional open-source.

3. **PostgreSQL**: Sistem database relasional open-source yang canggih.

4. **MongoDB**: Database NoSQL yang berorientasi dokumen.

5. **Redis**: Database key-value in-memory yang cepat.

6. **Cassandra**: Database NoSQL terdistribusi yang sangat skalabel.

7. **Elasticsearch**: Mesin pencari dan analisis terdistribusi.

## E. Pengembangan Mobile

1. **Android Studio**: Lingkungan pengembangan terintegrasi (IDE) resmi untuk pengembangan aplikasi Android.

2. **Kotlin**: Bahasa pemrograman modern yang digunakan untuk pengembangan Android.

3. **Swift**: Bahasa pemrograman untuk pengembangan aplikasi iOS.

4. **React Native**: Framework untuk membangun aplikasi mobile lintas platform menggunakan React.

5. **Flutter**: SDK dari Google untuk membangun aplikasi mobile, web, dan desktop dari satu basis kode.

6. **Xamarin**: Platform pengembangan aplikasi mobile lintas platform menggunakan C#.

## F. Cloud Computing dan Infrastruktur

1. **AWS (Amazon Web Services)**: Platform cloud computing yang menyediakan berbagai layanan.

2. **Google Cloud Platform**: Suite layanan cloud computing dari Google.

3. **Microsoft Azure**: Platform cloud computing dari Microsoft.

4. **Docker**: Platform untuk mengemas, mendistribusikan, dan menjalankan aplikasi dalam container.

5. **Kubernetes**: Sistem orkestrasi container open-source.

6. **Serverless Computing**: Model eksekusi komputasi di mana penyedia cloud mengelola alokasi sumber daya secara dinamis.

## G. Version Control dan Kolaborasi

1. **Git**: Sistem kontrol versi terdistribusi.

2. **GitHub**: Platform hosting untuk repositori Git dan kolaborasi.

3. **GitLab**: Platform DevOps berbasis web yang menyediakan kontrol versi dan CI/CD.

4. **Bitbucket**: Layanan hosting repositori Git dan Mercurial.

## H. Keamanan dan Pengujian

1. **Penetration Testing**: Praktik menguji sistem komputer, jaringan, atau aplikasi web untuk menemukan kerentanan keamanan.

2. **Encryption**: Proses mengubah informasi menjadi kode untuk mencegah akses yang tidak sah.

3. **OAuth**: Protokol otorisasi open standard.

4. **Unit Testing**: Metode pengujian perangkat lunak di mana unit individual kode diuji.

5. **Integration Testing**: Fase dalam pengujian perangkat lunak di mana modul perangkat lunak individual digabungkan dan diuji sebagai sebuah grup.

6. **Continuous Integration (CI)**: Praktik mengintegrasikan kode ke dalam repositori bersama secara rutin.

7. **Continuous Deployment (CD)**: Praktik merilis perangkat lunak secara otomatis ke produksi.

## I. Konsep dan Paradigma Pemrograman

1. **Object-Oriented Programming (OOP)**: Paradigma pemrograman berdasarkan konsep "objek".

2. **Functional Programming**: Paradigma pemrograman yang memperlakukan komputasi sebagai evaluasi fungsi matematika.

3. **Reactive Programming**: Paradigma pemrograman dengan aliran data asynchronous dan propagasi perubahan.

4. **Concurrency**: Kemampuan program untuk menjalankan beberapa komputasi secara bersamaan.

5. **Parallelism**: Eksekusi simultan dari perhitungan independen.

6. **Asynchronous Programming**: Model pemrograman yang memungkinkan operasi berjalan secara non-blocking.

## J. Artificial Intelligence dan Machine Learning

1. **Neural Network**: Model komputasi yang terinspirasi oleh sistem saraf biologis.

2. **Deep Learning**: Subset dari machine learning yang menggunakan jaringan neural berlapis banyak.

3. **Natural Language Processing (NLP)**: Cabang AI yang berfokus pada interaksi antara komputer dan bahasa manusia.

4. **Computer Vision**: Bidang AI yang melatih komputer untuk menginterpretasikan dan memahami dunia visual.

5. **Reinforcement Learning**: Area machine learning yang berfokus pada bagaimana agen harus mengambil tindakan dalam suatu lingkungan.

## K. Istilah Spesifik yang Anda Sebutkan

1. **Backend**: Bagian dari aplikasi yang menangani logika bisnis dan interaksi dengan database.

2. **Widget (UI/User Interface)**: Elemen antarmuka pengguna yang dapat digunakan kembali.

3. **XML (UI/User Interface)**: Bahasa markup yang sering digunakan untuk mendefinisikan layout UI dalam pengembangan Android.

4. **Compose (UI/User Interface)**: Toolkit modern untuk membangun native UI di Android.

5. **API (Application Programming Interface)**: Set definisi, protokol, dan alat untuk membangun software aplikasi.

6. **Retrofit**: Library HTTP Client untuk Android dan Java.

7. **Volley**: Library HTTP untuk mentransmisikan data jaringan pada aplikasi Android.

8. **Fast Android Networking**: Library networking untuk Android.

9. **Room**: Library persistence yang menyediakan lapisan abstraksi di atas SQLite.

10. **SQLite**: Database relasional ringan yang populer digunakan dalam aplikasi mobile.

11. **Realm**: Database objek mobile.

# Informmatika

# Dalam Dunia Pemrograman

Konsistensi dalam pemrograman sangat penting. Konsistensi membantu memastikan bahwa kode lebih mudah dipahami, didokumentasikan, dan diperawat oleh berbagai orang. Ini juga membantu dalam mengurangi kesalahan dan memudahkan integrasi dengan sistem lain.

Konsistensi mencakup banyak aspek, seperti:

- **Stil kode**: Menggunakan gaya penulisan yang konsisten (misalnya, pemilihan nama variabel, indentasi, dan struktur kode).
- **Penggunaan teknologi**: Menggunakan teknologi dan alat yang konsisten (misalnya, framework, library, dan alat build).
- **Proses kerja**: Mengikuti prosedur dan praktik kerja yang konsisten (misalnya, penggunaan versi control, testing, dan deployment).

Dengan konsistensi, tim dapat bekerja lebih efisien dan produk akhir menjadi lebih stabil dan andal. Selain itu, beberapa hal lain yang juga sangat penting dalam pemrograman diantaranya mencakup berikut:

1. **Kode yang Jelas dan Terstruktur**: Kode yang mudah dibaca dan dipahami oleh orang lain sangat penting. Ini termasuk penggunaan nama variabel yang deskriptif, komentar yang membantu, dan struktur kode yang logis.

2. **Testing dan Debugging**: Menulis test cases dan melakukan debugging secara rutin membantu mengidentifikasi dan mengatasi masalah sejak dini. Ini juga memastikan bahwa perubahan tidak mengganggu fungsi yang sudah ada.

3. **Dokumentasi yang Baik**: Dokumentasi yang jelas dan komprehensif membantu orang lain memahami bagaimana kode bekerja dan bagaimana cara memperbaikinya atau memperluasnya.

4. **Pemeliharaan Kode**: Kode yang mudah diperbaiki dan diperbarui sangat penting untuk keberlanjutan proyek. Ini termasuk penggunaan desain modular dan menghindari pengkodean yang terlalu rumit.

5. **Komunikasi yang Efektif**: Bekerja dalam tim memerlukan komunikasi yang baik. Memastikan bahwa semua anggota tim memahami tujuan dan bagaimana mereka dapat berkontribusi adalah kunci kesuksesan.

6. **Pemahaman Teknologi dan Alat**: Memahami dan menggunakan alat yang tepat untuk tugas tertentu, seperti version control (misalnya Git), alat build, dan testing tools, sangat penting.

7. **Pemahaman Masalah dan Desain**: Mampu memecahkan masalah dan merancang solusi yang efisien adalah keterampilan yang sangat berharga dalam pemrograman.

Kombinasi dari semua hal ini membantu menciptakan kode yang tidak hanya berfungsi dengan baik tetapi juga mudah dipelihara dan diperluas.

#

Sebenarnya masih ada banyak hal lain yang bisa diperhatikan dalam pemrograman. Beberapa di antaranya adalah:

1. **Pemahaman Prinsip-Prinsip Dasar**: Memahami konsep-konsep dasar seperti algoritma, struktur data, dan pemrograman berorientasi objek dapat membantu dalam menulis kode yang lebih efisien dan efektif.

2. **Penggunaan Alat Version Control**: Memahami dan menggunakan alat version control seperti Git sangat penting untuk mengelola perubahan kode dan bekerja dalam tim.

3. **Pemahaman Bahasa Pemrograman**: Memiliki pemahaman mendalam tentang bahasa pemrograman yang digunakan sangat penting. Ini termasuk pengetahuan tentang fitur-fitur, kelemahan, dan cara terbaik untuk menggunakan bahasa tersebut.

4. **Pemahaman Arsitektur**: Memahami berbagai arsitektur pemrograman dan bagaimana menerapkannya dapat membantu dalam merancang sistem yang lebih skalabel dan mudah diperbaiki.

5. **Keamanan**: Memastikan bahwa kode yang ditulis aman dari ancaman keamanan seperti SQL injection, cross-site scripting (XSS), dan lain-lain adalah hal yang sangat penting.

6. **Pemahaman Teknologi Terbaru**: Terus belajar tentang teknologi dan tren terbaru dalam dunia pemrograman dapat membantu dalam mengembangkan keterampilan dan mempertahankan relevansi di industri.

7. **Keterampilan Soft Skills**: Selain keterampilan teknis, kemampuan komunikasi, kerja tim, dan manajemen waktu juga sangat penting dalam karier sebagai programmer.

8. **Pemahaman Pengguna**: Mengerti siapa pengguna akhir dan bagaimana mereka akan menggunakan produk dapat membantu dalam merancang antarmuka yang lebih intuitif dan memuaskan.

Semua aspek ini bersama-sama membantu bukan hanya dalam menciptakan pengalaman pemrograman yang sangat baik tetapi juga untuk sebuah produk yang nantinya juga jauh lebih baik.

# Pemrograman

# Kamus Istilah Coding

## A

- **Algoritma**: Serangkaian langkah logis untuk menyelesaikan masalah atau tugas tertentu
- **Array**: Struktur data yang menyimpan kumpulan elemen dengan tipe yang sama
- **Abstraksi**: Proses menyederhanakan kompleksitas dengan menyembunyikan detail yang tidak perlu

## B

- **Backend**: Bagian server dari sebuah aplikasi yang mengatur logika, database, dan proses utama
- **Boolean**: Tipe data dengan dua nilai: benar (true) atau salah (false)
- **Bug**: Kesalahan atau defek dalam kode yang menyebabkan program tidak berfungsi dengan benar

## C

- **Compiler**: Program yang menerjemahkan kode sumber menjadi kode mesin
- **Class**: Blueprint untuk membuat objek dalam pemrograman berorientasi objek
- **Callback**: Fungsi yang dijalankan setelah fungsi lain selesai dieksekusi

## D

- **Database**: Kumpulan data terorganisir yang disimpan dan diakses secara elektronik
- **Debugging**: Proses menemukan dan memperbaiki kesalahan dalam kode
- **Deklarasi**: Pernyataan yang mendefinisikan variabel atau fungsi

## E

- **Enkapsulasi**: Konsep menyembunyikan detail internal suatu objek
- **Exception**: Kejadian yang terjadi selama eksekusi program yang mengganggu aliran normal
- **Ekspresi**: Kombinasi variabel, operator, dan nilai yang menghasilkan suatu nilai

## F

- **Framework**: Kerangka kerja yang menyediakan struktur dasar untuk pengembangan perangkat lunak
- **Fungsi**: Blok kode yang dirancang untuk melakukan tugas tertentu
- **Frontend**: Bagian antarmuka pengguna dari sebuah aplikasi

## G

- **Git**: Sistem kontrol versi terdistribusi untuk melacak perubahan kode
- **Getter**: Metode untuk mengambil nilai properti dalam suatu kelas
- **GUI**: Antarmuka pengguna grafis

## H

- **Hardware**: Komponen fisik dari sistem komputer
- **Heap**: Area memori untuk alokasi dinamis
- **HTTP**: Protokol transfer data untuk komunikasi di web

## I

- **Inheritance**: Mekanisme di mana sebuah kelas dapat mewarisi properti dan metode dari kelas lain
- **Iterasi**: Proses pengulangan serangkaian instruksi
- **Indeks**: Posisi elemen dalam array atau struktur data

## J

- **JSON**: Format pertukaran data ringan
- **Java**: Bahasa pemrograman berorientasi objek
- **JVM**: Mesin virtual Java untuk menjalankan bytecode

## K

- **Kompilasi**: Proses menerjemahkan kode sumber menjadi kode yang dapat dieksekusi
- **Kelas Abstrak**: Kelas yang tidak dapat diinstansiasi secara langsung
- **Kursor**: Penanda posisi dalam database atau struktur data

## L

- **Library**: Kumpulan kode siap pakai yang dapat digunakan dalam pengembangan
- **Lingkup (Scope)**: Area di mana variabel dapat diakses
- **Loop**: Struktur kontrol untuk mengulang serangkaian pernyataan

## M

- **Metode**: Fungsi yang terkait dengan suatu kelas
- **Mutator**: Metode untuk mengubah nilai properti dalam suatu kelas
- **Map**: Struktur data yang menyimpan pasangan kunci-nilai

## N

- **Namespace**: Ruang lingkup untuk mengorganisir kode dan menghindari konflik nama
- **NULL**: Nilai yang menunjukkan tidak adanya objek atau nilai
- **Node**: Struktur data dasar dalam graph atau tree

## O

- **Objek**: Instance dari suatu kelas
- **Overloading**: Kemampuan membuat beberapa metode dengan nama yang sama tetapi parameter berbeda
- **Open Source**: Perangkat lunak dengan kode sumber terbuka

## P

- **Pointer**: Variabel yang menyimpan alamat memori
- **Polimorfisme**: Kemampuan objek untuk memiliki banyak bentuk
- **Protokol**: Aturan komunikasi antara sistem komputer

## R

- **Rekursi**: Metode di mana fungsi memanggil dirinya sendiri
- **Runtime**: Periode saat program sedang dieksekusi
- **Refactoring**: Proses restrukturisasi kode tanpa mengubah perilaku eksternal

## S

- **String**: Tipe data untuk menyimpan teks
- **Setter**: Metode untuk mengatur nilai properti dalam suatu kelas
- **Sintaks**: Aturan penulisan kode dalam bahasa pemrograman

## T

- **Tipe Data**: Klasifikasi jenis data yang dapat disimpan
- **Thread**: Unit eksekusi independen dalam sebuah program
- **Tree**: Struktur data hierarkis

## V

- **Variabel**: Wadah untuk menyimpan data
- **Versi**: Nomor atau penanda perubahan dalam perangkat lunak
- **Virtual**: Konsep yang ada secara logis tetapi tidak secara fisik

## W

- **Web Service**: Metode komunikasi antara dua perangkat elektronik melalui web
- **While Loop**: Perulangan yang mengeksekusi blok kode selama kondisi terpenuhi

#

**Incremental :** berarti meningkat atau berkembang secara bertahap dan terus-menerus dalam jumlah kecil atau langkah-langkah kecil.

---

**Subroutine** adalah blok kode yang dapat dipanggil berulang kali dari berbagai bagian program untuk melakukan tugas tertentu. Subroutine membantu:

**Mengurangi duplikasi kode:** Dengan memisahkan kode yang sering digunakan ke dalam subroutine, kamu tidak perlu menulis kode yang sama berulang kali.

**Meningkatkan modularitas:** Subroutine memungkinkan kamu memecah program menjadi bagian-bagian yang lebih kecil dan lebih mudah dikelola.

**Meningkatkan reusabilitas:** Subroutine dapat digunakan kembali di berbagai bagian program atau bahkan di program lain.
Subroutine sering disebut sebagai fungsi atau prosedur, tergantung pada apakah mereka mengembalikan nilai atau tidak.

---

**Placeholder** adalah istilah yang digunakan untuk menggambarkan sesuatu yang sementara atau penanda yang digunakan untuk mengisi ruang atau posisi tertentu sampai digantikan oleh konten atau objek yang sebenarnya. Placeholder bisa berupa:

**Teks placeholder:** Digunakan dalam dokumen atau formulir untuk menunjukkan di mana teks sebenarnya akan ditempatkan.

**Gambar placeholder:** Digunakan dalam desain grafis atau web untuk menandai area yang akan diisi dengan gambar sebenarnya.

**Variabel placeholder:** Digunakan dalam pemrograman untuk menampung nilai sementara atau default.

Placeholder membantu dalam proses pengembangan, desain, atau pengisian data dengan memberikan struktur dan format yang jelas sebelum konten akhir ditambahkan.

---

**Mark-and-sweep** adalah algoritma pengelolaan memori yang digunakan dalam garbage collection (pengumpulan sampah) untuk mengidentifikasi dan menghapus objek yang tidak lagi digunakan dalam program. Berikut cara kerjanya:

**Mark:** Algoritma memulai dengan menandai semua objek yang dapat dijangkau dari root (titik awal program). Objek yang terjangkau dianggap masih digunakan.

**Sweep:** Setelah penandaan selesai, algoritma melakukan "sweep" untuk mengidentifikasi objek yang tidak ditandai. Objek yang tidak ditandai dianggap tidak lagi digunakan dan memori mereka dapat dibebaskan.

Mark-and-sweep membantu mengelola memori secara efisien dan mencegah kebocoran memori dengan membersihkan objek yang tidak lagi diperlukan.

---

**Invisible** berarti tidak dapat dilihat atau tidak terlihat. Ini bisa merujuk pada:

**Objek atau entitas tidak terlihat:** Seperti gas, udara, atau partikel kecil yang tidak dapat dilihat dengan mata telanjang.

**Desain atau elemen tidak terlihat:** Seperti elemen desain yang sengaja dibuat tidak terlihat atau transparan.
Konsep atau perasaan tidak terlihat: Seperti perasaan atau pikiran yang tidak terlihat secara fisik.

Dalam berbagai konteks, "invisible" bisa digunakan untuk menggambarkan sesuatu yang tidak dapat dilihat atau dipersepsikan secara langsung.

---

**Pure** bisa memiliki beberapa arti tergantung konteksnya:

**Murni:** Tidak tercampur dengan zat lain, seperti air murni atau emas murni.

**Sederhana:** Tanpa tambahan atau hiasan, seperti desain yang pure dan minimalis.
**Tulus:** Tanpa motif tersembunyi, seperti niat yang pure dan ikhlas.

Dalam berbagai konteks, "pure" bisa merujuk pada kemurnian, kesederhanaan, atau ketulusan.

---

**Milestone** adalah titik penting atau pencapaian signifikan dalam sebuah proyek atau proses. Ini digunakan untuk menandai kemajuan dan mencapai tujuan tertentu. Dalam pengembangan perangkat lunak, milestone sering digunakan untuk:

**Menentukan tujuan:** Mengatur target dan harapan untuk setiap tahap proyek.

**Mengukur kemajuan:** Menilai progres dan mengidentifikasi area yang perlu perbaikan.

**Mengatur waktu:** Menjadwalkan dan mengelola waktu untuk setiap tahap proyek.

Milestone membantu tim proyek tetap fokus, terorganisir, dan termotivasi untuk mencapai tujuan.

---

**Skeleton:** Dalam konteks teknologi, skeleton bisa merujuk pada kerangka atau struktur dasar dari sebuah sistem atau aplikasi yang dibangun untuk mendukung fungsi-fungsi tertentu.

---

Dalam pemrograman, istilah **argument** dan **parameter** seringkali digunakan secara bergantian, tetapi sebenarnya memiliki makna yang berbeda.

**Parameter** adalah variabel yang didefinisikan dalam deklarasi fungsi atau metode. Parameter adalah placeholder untuk nilai yang akan diteruskan ke fungsi saat fungsi tersebut dipanggil.

**Argument**, di sisi lain, adalah nilai yang sebenarnya diteruskan ke fungsi saat fungsi tersebut dipanggil. Argument adalah nilai konkret yang menggantikan parameter dalam fungsi.
Contoh sederhana dalam Python:

```
def tambah(a, b):  # a dan b adalah parameter
    return a + b

hasil = tambah(3, 5)  # 3 dan 5 adalah argument
```

Dalam contoh di atas, a dan b adalah parameter yang didefinisikan dalam fungsi tambah. Saat fungsi tambah dipanggil dengan nilai 3 dan 5, maka 3 dan 5 adalah argument yang diteruskan ke fungsi tersebut.

**Analogi Sederhana:**

**Parameter** seperti **_"kotak"_** yang menunggu untuk diisi
**Argument** seperti **_"isi"_** yang dimasukkan ke dalam kotak tersebut

Jadi, saat seorang programer memanggil fungsi, dia memasukkan argument (isi) ke dalam parameter (kotak) yang telah didefinisikan sebelumnya.

---

**Reassign** berarti memberikan nilai baru kepada variabel yang sudah ada, sehingga nilai lama digantikan oleh nilai baru. Dalam pemrograman, reassign memungkinkan kamu untuk mengubah nilai variabel sesuai kebutuhan program.
Contoh:

```
x = 5  # nilai awal
x = 10  # reassign nilai x menjadi 10
```

Dalam contoh di atas, nilai x awalnya adalah 5, tapi kemudian di-reassign menjadi **10**. Reassign berguna dalam berbagai situasi, seperti:

Mengupdate nilai variabel berdasarkan input pengguna

Mengubah status program berdasarkan kondisi tertentu

Mengoptimalkan kode dengan mengurangi kebutuhan variabel baru

---

[Buffer:][buffer] Anggap saja semacam penyanggah samar yang ditujukan sementara sebelum akhirnya dapat berubah peran seperti dia mungkin dapat menghapus apa yang disanggah setelah tujuan intinya berhasil

---

---


[486]: ../konsep/regex/README.md

<h3 id="satu"></h3>

**[Home][1]**

[1]: ../../README.md
[dsl]: ../../README.md
[escape]: ./escape/README.md
[buffer]: ./buffer/README.md
